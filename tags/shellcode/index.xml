<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shellcode on Solar Bits</title>
    <link>https://thuri10.github.io/tags/shellcode/</link>
    <description>Recent content in shellcode on Solar Bits</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Dec 2021 19:02:24 +0300</lastBuildDate><atom:link href="https://thuri10.github.io/tags/shellcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reversing Custom Bytecode Virtual Machine</title>
      <link>https://thuri10.github.io/p/reversing-custom-bytecode-virtual-machine/</link>
      <pubDate>Tue, 07 Dec 2021 19:02:24 +0300</pubDate>
      
      <guid>https://thuri10.github.io/p/reversing-custom-bytecode-virtual-machine/</guid>
      <description>vm1.exe implements a simple 8-bit virtual machine (VM) to try and stop reverse engineers from retrieving the flag. The VM’s RAM contains the encrypted flag and some bytecode to decrypt it. Can you figure out how the VM works and write your own to decrypt the flag? A copy of the VM’s RAM has been provided in ram.bin (this data is identical to the ram content of the malware’s VM before execution and contains both the custom assembly code and encrypted flag).</description>
    </item>
    
    <item>
      <title>Static analysis of Malware Strings</title>
      <link>https://thuri10.github.io/p/static-analysis-of-malware-strings/</link>
      <pubDate>Tue, 07 Dec 2021 19:02:13 +0300</pubDate>
      
      <guid>https://thuri10.github.io/p/static-analysis-of-malware-strings/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
